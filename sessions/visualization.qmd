# Basic data visualization {#sec-visualization}

```{r setup}
#| include: false
library(tidyverse)
nhanes_small <- read_csv(here::here("data/nhanes_small.csv"))
```

<!-- TODO: Add an introduction here -->

<!-- TODO: Add text about using Quarto options for figures -->

**Session objectives**:

1.  Learn and apply the basics of creating publication-quality graphs.
2.  Learn the importance of considering the colours you use in your
    graphs and apply tools that are colour-blind friendly.
3.  Learn why to avoid using commonly used, but inappropriate, graphs
    for presenting results.
4.  Create useful graphs such as boxplots, scatterplots, line graphs,
    jitter plots, and (appropriate) barplots.

## Basic principles for creating graphs

::: callout-note
## Reading task: \~4 minutes

Making graphs in R is relatively easy compared to other programs and can
be done with very little code. Because it takes few lines of code to
great multiple types of plots, it gives you some time to consider: *why*
you are making them; whether the graph you've selected is the *most
appropriate* for your data or results; and how you can design your
graphs to be as accessible and understandable as possible.

To start, here are some tips for making a graph:

-   Whenever possible or reasonable, show raw data values rather than
    summaries (e.g. means).
-   Though commonly used in scientific papers, [*avoid
    barplots*](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128)
    with means and error bars as they greatly misrepresent the data
    (we'll cover why later).
-   Use colour to highlight and enhance your message, and make the plot
    visually appealing.
-   Use a colour-blind friendly palette to make the plot more accessible
    to others (more on this later too).

There are also excellent online books on this that are included in the
[resources](https://guides.rostools.org/learning.html) page of the
Guides website.
:::

## Basic structure of using ggplot2

::: callout-note
## Reading task: \~6 minutes

`{ggplot2}` is an implementation of the ["Grammar of
Graphics"](https://www.springer.com/gp/book/9780387245447) (gg). This is
a powerful approach to creating plots because it provides a set of
structured rules (a "grammar") that allow you to expressively describe
components (or "layers") of a graph. Since you are able to describe the
components, it is easier to then implement those "descriptions" in
creating a graph. There are at least four aspects to using ggplot2 that
relate to its "grammar":

-   Aesthetics, `aes()`: How data are mapped to the plot, including what
    data are put on the x and y axes, and/or whether to use a colour for
    a variable.
-   Geometries, `geom_` functions: Visual representation of the data, as
    a layer. This tells ggplot2 how the aesthetics should be visualized,
    including whether they should be shown as points, lines, boxes,
    bins, or bars.
-   Scales, `scale_` functions: Controls the visual properties of the
    `geom_` layers. Can be used to modify the appearance of the axes, to
    change the colour of dots from, e.g., red to blue, or to use a
    different colour palette entirely.
-   Themes, `theme_` functions or `theme()`: Directly controls all other
    aspects of the plot, such as the size, font, and angle of axis text,
    and the thickness or colour of the axis lines.

There is a massive amount of features in ggplot2. Thankfully,
`{ggplot2}` was specifically designed to make it easy to find and use
its functions and settings using tab auto-completion. To demonstrate
this feature, try typing out `geom_` and then hitting `Tab`. You will
get a list of all the geoms available. You can use this with `scale_` or
the options inside `theme()`. Try typing out `theme(axis.` and then
hitting `Tab`, and a list of theme settings related to the axis will pop
up.

So, why do we teach `{ggplot2}` and not base R plotting? Base R plotting
functionality is quite good and you can make really nice
publication-quality graphs. However, there are several major limitations
to base R plots from a beginner and a user-interface perspective:

-   Function and argument names are inconsistent and opaque (e.g. the
    `cex` argument can be used to magnify text and symbols, but you
    can't immediately tell from the name that it does that).
-   User-friendly documentation that is accessible to a broad range of
    people is not much of a priority, so often the help documentation
    isn't written with beginners in mind.
-   Graphs are built similar to painting on a canvas; make a mistake and
    you need to start all over (e.g. restart R).

These limitations are due to the fact that base R plotting was
developed:

-   By different people over different periods of time.
-   By people who were/are mostly from statistics and maths backgrounds.
-   By people who (generally) don't have training in principles of
    software user-design, user-interface, or engineering.
-   Without a strong "design philosophy" to guide development.
-   During a time when auto-completion didn't really exist or was
    sub-optimal, so short function and object names were more important
    than they are today.

On the other hand, `{ggplot2}`:

-   Has excellent documentation for help and learning.
-   Has a strong design philosophy that makes it easier to use.
-   Works in "layers", so you don't have to start over if you make a
    mistake.
-   Works very well with auto-completion.
-   Uses function and argument naming that is consistent and
    *descriptive* (in plain English).

These are the reasons we teach and use `{ggplot2}`.
:::

## Graph individual variables

Very often you want to get a sense of your data, one variable (i.e.
column in a data frame) at a time. You create plots to see the
distribution of a variable and visually inspect the data for any
problems. There are several ways of plotting continuous variables like
age or BMI in `{ggplot2}`. For discrete variables like education status,
there is really only one way.

You may notice that, since the Data Wrangling session (@sec-wrangling),
we have been using the term "column" to describe the columns in the data
frame, but from this point forward, we will instead refer to them as
"variable". There's a reason for this: `{ggplot2}` really only works
with tidy data. If we recall the definition of tidy data, it consists of
"variables" (columns) and "observations" (rows) of a data frame. To us,
a "variable" is something that we are interested in analyzing or
visualizing, and which only contains values relevant to that measurement
(e.g. `age` variable must only contain values for age).

The `NHANES` dataset is already pretty tidy. Rows are participants at
the survey year and columns are the variables that were measured. Let's
visually explore our data. In the `LearningR` project in the
`docs/learning.qmd` file, create a new second-level header on the bottom
of the file called `## Visualizing data`. Now, we are ready to start
creating the first plot!

### One continuous variable

Since BMI is a strong risk factor for diabetes, let's check out the
distribution of BMI among the participants. There are two good geoms for
examining distributions for continuous variables: `geom_density()` and
`geom_histogram()`. How you use both is the same, so we will only show
the histogram geom.

Write out a new header called `### One variable plots` in the free text
area. Below it add a code chunk with {{< var keybind.chunk >}}. To make
use of auto-completion and to get used to using the pipe, we'll pipe the
data into the `ggplot()` function.

```{r}
#| filename: "docs/learning.qmd"
nhanes_small %>%
  ggplot(aes(x = bmi)) +
  geom_histogram()
```

You'll notice we get a warning about dropping missing values. That's
`{ggplot2}` letting us know we have some missing values. So, like with
`median()` and many of the other summary statistic functions, we can set
`na.rm = TRUE` to `geom_histogram()` and other `geom_*` functions.

```{r}
#| filename: "docs/learning.qmd"
nhanes_small %>%
  ggplot(aes(x = bmi)) +
  geom_histogram(na.rm = TRUE)
```

Note that it is good practice to always create a new line after the `+`.
Our plot shows that, for the most part, there is a good distribution
with BMI, although there are several values that are quite large,
including some at 80 BMI units! Let's use `{dplyr}` functions to remove
anything above 60. Because we are piping the results into `ggplot()`, we
can use `aes()` right away rather than put in the data object to the
first argument position.

```{r}
#| filename: "docs/learning.qmd"
nhanes_small %>%
  filter(bmi <= 60) %>%
  ggplot(aes(x = bmi)) +
  geom_histogram(na.rm = TRUE)
```

In general, it is good practice to create a new code chunk for each plot
in Quarto for several reasons. One, it makes it easier to maintain a
nice readable code and, two, there are some chunk options that only work
with one figure. However, it is possible to show multiple graphs for
instance side-by-side, as we will do later. Now we add a caption for the
plot with the option`#| fig-cap`. Let's add one as well as a figure
label with `#| label` so we can reference it in the text by using
`@fig-LABEL`. Figure labels **must** always start with `fig-`.

```{r}
#| echo: fenced
#| fig-cap: "Distribution of BMI."
#| label: fig-bmi-histo
nhanes_small %>%
  filter(bmi <= 60) %>%
  ggplot(aes(x = bmi)) +
  geom_histogram(na.rm = TRUE)
```

Now when we reference the figure in the text, we can use
`@fig-bmi-histo`, to look like this: @fig-bmi-histo.

### One discrete variable

The geoms above are appropriate for plotting continuous variables, but
what about plotting discrete variables? Well, sadly, there's really only
one: `geom_bar()`. This isn't a geom for a barplot though; instead, it
shows the counts of a discrete variable. There are many discrete
variables in NHANES, including education and diabetes, so let's use this
geom to visualize those. Again, create a new code chunk with
{{< var keybind.chunk >}} and type:

```{r discrete-variables}
#| filename: "docs/learning.qmd"
nhanes_small %>%
  ggplot(aes(x = education)) +
  geom_bar()
```

We can't use `na.rm = TRUE` here because `geom_bar()` includes that
information as a bar. We can see that the number of people in
progressively higher education statuses steadily increases, but there's
also a lot of missingness shown in the `NA` column. Now, we'll do the
same for the diabetes status variable. In the same code chunk, type:

```{r}
nhanes_small %>%
  ggplot(aes(x = diabetes)) +
  geom_bar()
```

For diabetes, it seems that there is some missingness in the data. Same
thing with education. Like we did with the BMI, we'll use `filter()` to
drop those missing rows right before plotting them. First create a new
code chunk with {{< var keybind.chunk >}}. Then we'll start with
diabetes and then copy and paste the code, replacing `diabetes` with
`education`.

```{r}
#| filename: "docs/learning.qmd"
nhanes_small %>%
  filter(!is.na(diabetes)) %>%
  ggplot(aes(x = diabetes)) +
  geom_bar()

nhanes_small %>%
  filter(!is.na(education)) %>%
  ggplot(aes(x = education)) +
  geom_bar()
```

We are plotting two figures here. With Quarto, we can arrange them side
by side in the output document by using the `#| layout-ncol` (or
`#| layout-nrow` or `#| layout`), described more in Quarto's
[Figures](https://quarto.org/docs/authoring/figures.html#subcaptions)
page. We can then combine it with captions and sub-captions using
`#| fig-subcap` to have a nice output!

```{r}
#| echo: fenced
#| label: fig-diabetes-education
#| fig-cap: "Counts of Diabetes and Education."
#| fig-subcap:
#|   - "Number of those with or without Diabetes."
#|   - "Number of those with different educational status."
#| layout-ncol: 2
nhanes_small %>%
  filter(!is.na(diabetes)) %>%
  ggplot(aes(x = diabetes)) +
  geom_bar()

nhanes_small %>%
  filter(!is.na(education)) %>%
  ggplot(aes(x = education)) +
  geom_bar()
```

Render the document with {{< var keybind.render >}} to see what it looks
like! Neat eh :grinning:

::: {.callout-note appearance="minimal" collapse="true"}
## Instructor note

For this section on the bar-with-standard-error plots, make sure to go
over and emphasize the problems and major flaws with using this type of
plot. Really try to reinforce the concept here.
:::

Before continuing with plotting, let's take a minute to talk about a
commonly used barplots with mean and error bars. In all cases, barplots
should **only** be used for discrete (categorical) data where you want
to show counts or proportions. As a general rule, they should **not** be
used for continuous data. This is because the commonly used "bar plot of
means with error bars" actually hides the underlying distribution of the
data. To have a better explanation of this, you can read the article on
why to [avoid
barplots](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128)
after the course. The image below was taken from that paper, and briefly
demonstrates why this plot type is not useful.

::: {#fig-barplots-deceive}
![](../images/barplots-deceive.png){width="100%"}

Bars deceive what the data actually look like. Image sourced from a
[PLoS Biology
article](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128).
:::

If you *do* want to create a barplot, you'll quickly find out that it is
actually quite hard to do in `{ggplot2}`. The reason it is difficult to
create in `{ggplot2}` is by design: it's a bad plot to use, so use
something else.

::: {#fig-art-bar-error-plot}
![](../images/art-bar-error-plot.png){width="70%"}

Barplots hide interesting results. Artwork by
[\@allison_horst](https://github.com/allisonhorst/stats-illustrations).
:::

Before we move on, let's run `{styler}` using
{{< var keybind.styler >}}, then add and commit the new files we created
into the Git history with {{< var keybind.git >}} and push up to your
GitHub repository.

## Plotting two variables

There are many more types of "geoms" to use when plotting two variables.
Your choice of which one to use depends on what you are trying to show
or communicate, and the nature of the data. Usually, the variable that
you "control or influence" (the independent variable) in an experimental
setting goes on the x-axis, and the variable that "responds" (the
dependent variable) goes on the y-axis.

### Two continuous variables

When you have *two continuous* variables, some geoms to use are:

-   `geom_hex()`, which is used to replace `geom_point()` when your data
    are *massive* and creating points for each value takes too long to
    plot. Because we have a lot of data, we will show this one.
-   `geom_point()`, which is used to create a standard scatterplot.
    You'll use this one in the exercise, it is used the same way as
    other geoms.
-   `geom_smooth()`, which applies a "regression-type" line to the data
    (default uses LOESS regression).

Let's check out how BMI may influence systolic blood pressure using a
hex plot in a new code chunk. First, enter a new Markdown header called
`### Plotting two variables` and create a new code chunk below the
header with {{< var keybind.chunk >}}. Like with the previous plot we
created using `bmi`, we'll use `na.rm` again.

```{r 2-continuous-variables}
#| filename: "docs/learning.qmd"
nhanes_small %>%
  ggplot(aes(x = bmi, y = bp_sys_ave)) +
  geom_hex(na.rm = TRUE)
```

Notice how the hex plot changes the colour of the data based on how many
values are in the area of the plot. We can also draw a smoothing line by
adding to the plot by using `+`.

```{r}
nhanes_small %>%
  ggplot(aes(x = bmi, y = bp_sys_ave)) +
  geom_hex(na.rm = TRUE) +
  geom_smooth(na.rm = TRUE)
```

This makes a nice smoothing line through the data and gives us an idea
of general trends or relationships between the two variables.
