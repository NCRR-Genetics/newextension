# Version control with Git {#version-control}

![](https://img.shields.io/badge/document%20status-in%20progress-orange?style=flat-square)

> When in RStudio, quickly jump to this page using `r3::open_version_control()`.

**Session objectives**:

1. Learn about "formal" version control and its importance.
1. Learn about Git for version control and apply RStudio's integrated Git tools.
1. Learn and apply the basic workflow of Git version control: 
View changes to files, record and save those changes to a history, 
and synchronize those changes to an online repository (GitHub).
1. Use GitHub to collaborate with others on a project.

# Outline

- What is and why use
- Git as version control, why Git?
- Pic of workflow
- RStudio and Git interface and using it
- Git workflow (pic)
    - Edit, Add, commit, check history/status
    - States (working, staged, history)
- Exercise to practice
- Collaborating using GitHub and using RStudio to "clone" repo
- Remotes, pushing, pulling (plus pic)
- Exercise
- Final exercise group work

## What is version control?

**Take 5 min and read through this section**.

!["Final" version of a document, using a common and simple "version control system". Image source: [PhD Comics](https://phdcomics.com/comics/archive_print.php?comicid=1531)](images/phd-comics-version-control.png)

![Filenaming used for the common "version control". Image source: [PhD Comics](https://phdcomics.com/comics.php?f=1323)](images/informal-version-control.gif)

Does this way of saving files and keeping track of versions look familiar?
While the above images are teasing a bit,
there is truth to is: it is the most commonly used "version control".

This form of version control, while common,
is fairly primitive, informal, and very manual.
It isn't ideal because it requires making multiple copies of the same file, 
even if changes made are done to only one small part of the file. 
This approach also makes it difficult to find specific changes done.

There are, however, formal version control systems 
that automatically manage changes to a file or files. 

These formal version control systems take snapshots of changes done to files,
which usually called "revisions" or "commits". 
These "commits" record what was changed since the previous "commit".
When you make these "commits",
you have to create a short message on what or why you made change.
These "commits" are stored as a log entry in a history.
This history then has all this information,
for each commit,
on what file or files were changed, 
what was changed within the file(s), 
who changed it, and the short message about the change.
This is extremely useful, 
especially when working in teams 
or for yourself 6 months in the future 
(because you *will* forget things),
since you can go back and quickly see what happened and why.

To understand how incredibly powerful version control is, 
think about these questions (or refer to the comic above!): 

- How many files of different versions of a manuscript 
or thesis do you have laying around after getting feedback from your supervisor 
or co-authors? 
- Have you ever wanted to experiment with your code 
or your manuscript 
and need to make a new file so that the original is not modified? 
- Have you ever deleted something and wish you hadn't?
- Have you ever forgotten what you were doing on a project?  

All these problems can fixed by using formal version control! 
There are so many good reasons to use version control, especially in science:

- Transparency of work done (to demonstrate or substantiate your scientific claim)
- Claim to first discovery (you have a time-stamped history of your work)
- Defend against fraud (because of the transparency)
- Evidence of contributions and work (who does what is tracked)
- Easily keep track of changes to files (by looking at the history of changes)
- Easy collaboration (because you can work on a single file/folder rather than emailing versions around)
- Organized files and folders (one single project folder and one single file, rather than multiple)
- Less time findings things (because everything is organized)

In this session we'll be covering a version control tool called [Git].
While Git on its own can be quite difficult to use, 
RStudio thankfully has an amazing and straight-forward integration to it.

[Git]: https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F

## What is Git?

Git is one of several version control system tools available.
It was developed to help the software programmers 
to develop and manage their work on [Linux]
(an operating system like Mac or Windows).
Sadly, it was designed by and for software programmers 
and not for non-programmer users (like us!).
So why do we teach it? 
Because there are so many great features of Git that fit with how science 
and data analysis is done!

- Like R, it is open source, so it's free and anyone can check that the code is correct
- It is very popular
and so has a very large online community that provides support, 
documentation, and tutorials on how to use it
- The vast majority of open source work, like developing R packages,
is done using Git and is hosted on [GitHub],
which is a company that hosts Git "repositories" (i.e. projects) online
    - All RStudio code and tidyverse packages are on GitHub
- There are many open scientific projects that use Git and are hosted on GitHub,
e.g. [rOpenSci](https://github.com/ropensci) organization,
[MRC Integrated Epidemiology Unit](https://github.com/MRCIEU)
- RStudio has an amazing interface and integration with Git

[GitHub]: https://github.com/

While learning Git and version control can be difficult 
and have a steep learning curve,
like learning R,
it is ultimately an investment into your future productivity 
and effectiveness as a researcher.
It is *very much worth it* to learn and use it as often as you can.

## Basics of Git

How Git works is by tracking changes to files *at the project level* 
(i.e. for every R Project).
So you won't track your entire, for instance, `My Documents/` folder.
When file changes are saved and put into the history,
this history is called a "repository" (also called a "repo" for short). 
We'll explain what a repository is more later.

For every project we need to setup 
and associate a Git repository with the project folder.
Before you continue, 
go into your `LearningR` R Project
and do a quick check to make sure that everyone has Git properly set up. 
Run this function in your RStudio Console:

```{r, eval=FALSE}
r3::check_git_config()
```

You shouldn't get an error and it should show your email and name.

- Set up a Git repository in your project
- Tell Git to track a file by preparing it to be saved to the history
- Record a message on what you are preparing to save to the history and then save it
 
Other things you'd do with Git:

- Check what's been changed or added in files since the last save
- Check the history for what was previously changed or add

When working with GitHub, there are extra things you'd do:

- Synchronize your Git repository on your computer with the repository on your GitHub,
called "push" (upload) and "pull" (download).

Set up a Git repository. (e.g. by checking box to start a Git repo when creating an R project,
automatically with prodigenr or with `usethis::use_git()`).

FORM MERELY USEFUL

Some questions to think about as you practice making commits:

- How often should you create new commits after making changes?
    - It's best to create commits fairly frequently, so that you have a good snapshot of your progress. If changes need to take effect at the same time on a group of files, you should commit them together; if changes are unrelated, it's a good idea to separate them into their own commits.
- What makes a good version control commit message?
    - A good commit message is succinct but meaningful. While many
developers can easily slip into commit messages like "@)#(*&#@)(*!", it's
worth the extra few seconds to type something meaningful, especially for our
next task: examining previous versions of files.

## Setting up a Git repository

First off, *what exactly is the Git repository?* 
Remember how your project folder is set up. There are actually several hidden files for Mac or Linux users or files
starting with `.` for Windows users. There are two important files/folders that
relate to Git, the `.gitignore` file and the `.git/` folder:

```
LearningR
├── .git/ <-- Here
├── R/
├── data/
├── doc/
├── .gitignore <-- Here
├── LearningR.Rproj
└── README.md
```

The `.gitignore` file tells Git to ignore tracking (or "watching") certain files
while the `.git/` folder contains all the changes and history for this folder...
This folder *is the repository*! Everything related to your project is found in 
that folder, so *don't delete it!*

To set up a repository we can either initialize immediately when we create a R
Project from the "New Projects" setup instructions. Or, if we already have a
R Project started we can use:

```{r, eval=FALSE}
usethis::use_git()
```

We now will be going through some steps in using Git in RStudio. We'll be doing
everything live through RStudio, so there is currently no coding involved right
now. See this excellent video on using [Git in RStudio]. We'll also be posting
the video of the session later on.

### Git stages overview

During the session we'll go over this image that goes over the different
"stages" in Git. There are basically four "stages" for files and changes:

1. Untracked files in the working folder.
2. Tracked (and possibly changed from previous version) files.
3. Files that have been changed and have been put into the "staging" area.
4. File changes stored in the history.

We won't be using the Git commands listed in the image. They are there for
reference.

```{r image-git-stages, echo=FALSE, fig.cap="The different stages of files and folders when using Git."}
knitr::include_graphics(here::here("images/git-stages.png"))
```

## The Git workflow

FROM MU

In the previous section, we set up an online copy of our project repository.
This wasn't too risky because our repository didn't have any large file or
confidential information. However, for some projects, that will be the case,
which is why it's important to think carefully before creating an online
repository.

Consider the following before you put it in an online repository:

- Size
    - GitHub has file size limits; you won't be *allowed* to upload files of
    a certain size. Projects with large data files often store their data in
    other places and then include directions of how to access it in the main
    project repository.
- Privacy
        - If your data includes identifying information or other confidential
    features, it should be placed in a location with the appropriate security.

## Exercise: Add and commit changes to README

## Git "remotes" (GitHub) overview

When we cover GitHub, we'll need to go over some additional concepts and
commands. When dealing with GitHub, we have the concept of "remotes". A remote
is a location for the Git repository other than the one you are working on. So 
in this case, the GitHub location of your repository is called the remote. A
remote can be anywhere, including on other version control services like GitLab.

Steps:

1. RStudio create from GitHub
2. Copy and paste folder contents into this newly created project
3. Add, commit.
4. Push to GitHub and confirm it pushed.

For both "owners" and "collaborators"

FROM MERELY USEFUL


To this point, we've used git features to track changes and compare versions
of files in our project repository. An additional way to use git to manage our
project is to create a duplicate of our project repository online. As we commit
changes to the project on our computer, we can periodically update the online
copy so that we have a backup. Sending changes from our computer to an online
copy is called "pushing" and if we want to get changes from the online copy to
our computer, the command is called "pulling." In what follows, we'll set up
a blank online repository and push and pull changes to and from it.

![remote-image](figures/py-version-control/tmp-remote.jpeg)

We'll be using GitHub as the home for the online copy of the project repository.
To start, create an empty repository on GitHub by going to the main Github
page and clicking on the green "New" button on the left. You must be logged in
for this to work!

You'll be taken to a screen that gives you some options about
your new repository - because we want it to be blank, leave all the options as
they are. The only piece you need to fill in is a name for the repository. This
doesn't have to be the same as the folder on your computer, but for clarity, it
should be clear that they're related.


## Exercise: Push your R files to GitHub

## Downloading (cloning) GitHub repositories with RStudio

## Exercise: Clone the instructor's repository

## Dealing with conflicts

FROM MERELY USEFUL

Even the most careful person will end up making changes in two different copies
of the same repository and then trying to sync them together. Sometimes git is
able to resolve the differences on its own, but sometimes the two changes conflict
and can't be automatically reconciled.

We can create a conflict like this by making changes in our `README.md` file.
First, make sure that your local repository and Github repository are synced
up - that you have pushed all your local changes to Github and pulled all your
Github changes to your local computer.

Then, **on your computer**, make these changes to the `README.md` file:

```
## Meeting time

- December 21, 2019
- 18:00 UTC
```

Commit the changes as we've done before but do **not** push them to Github.

Now, go to your repository on Github, click on the `README.md` file and edit
it as follows:

```
## Meeting time

- November 4, 2018
- 18:00 UTC
```

Commit the changes.

Now we have conflicting changes in our repository—one in the Github copy
and one on our local computer copy.

We want to sync our changes by either pushing from the copy on our computer to
the Github copy or by pulling from the Github copy to our computer. It turns
out that we can't do the first option (try it and see what happens), so we'll
have to use the second option, of pulling from Github to our computer. When
we try this, we should get a few red boxes that pop up saying "Pull failed"
and/or "Merge failed".

> Note that, when we try to push, we *do* have the option of using a "force
push" to override whatever changes we made in Github. If you're absolutely
sure that there's nothing in the Github copy you want, you can try this, but
it's generally a good idea to pull down the changes and look at the conflict,
just to make sure.

Because of the conflicting changes we made, the update of our
local repository failed. Git doesn't know
which changes we really want and has pushed us into a temporary "conflict"
state until we tell it specificallly which changes we want.

To do this, click on "View conflict" (should be on the top right of the
GitKraken window). Click on the file in conflict (`README.md`). This will
open up a different view, where the two conflicting versions of the file
are shown side by side. You can check the box picking one version, the other,
or both, with the combined output shown in the window below. Once you've
picked what you're happy with, click the "Save" button on the top right, close
the file by clicking the "X" and finish the update by clicking on
"Commit and merge" (Figure \@ref(fig:py-version-control-committing)).

```{r py-version-control-committing, echo=FALSE, fig.cap="The Commit Process"}
knitr::include_graphics("figures/FIXME.png")
```

## Outline

Show how to create a new project with Git init.

How to write messages.

```{r image-git-stages, echo=FALSE, fig.cap="The three stages files and folders are in when using Git."}
knitr::include_graphics(here::here("images/git-stages.png"))
```

### Exercise: Committing to history

Time: 10 min

- Practice the add-commit sequence by adding and 
committing each of the remaining files in your R project one by one into the Git history.
    - Make sure to write a meaningful and short message about what you added and why.
- Once all the files have been added and committed, 
add a new line to the `R/version-control-session.R` with an R comment 
(starts with a `#`).
Type out something like "This will be used for testing out Git".

### "Remotes": Storing your repository online

```{r image-git-remotes, echo=FALSE, fig.cap="The 'remote' vs 'local' repository, or online vs on your computer."}
knitr::include_graphics(here::here("images/git-remotes.png"))
```

TODO: Gif or video of making new github repo

TODO: Gif or video of cloning from RStudio

TODO: Gif or video of pushing and pulling from RStudio.

### Exercise: Clone GitHub repository from RStudio

Time: 8 min

- Create a new practice GitHub repository (name it `practice-repo`),
and include a README file as well (see image above).
- Create a new RStudio R project of the newly created GitHub repository.
Clone it to your desktop.

### Synchronizing with GitHub

```{r image-git-remotes-synch, echo=FALSE, fig.cap="Synchronizing with GitHub: 'Pushing' and 'pulling'."}
knitr::include_graphics(here::here("images/git-remotes-synch.png"))
```

```{r image-git-stages-with-github, echo=FALSE, fig.cap="Which stages get pushed and pulled."}
knitr::include_graphics(here::here("images/git-stages-with-github.png"))
```

TODO: Gif of editing a file in Github

### Exercise: Push and pull

Time: 10 min

- Using the `practice-repo` project you just created, 
open up the `README.md` file in RStudio.
- Add a one or two sentence simple 
and fake description of the project to the `README.md` file.
Add and commit the change. 
- Push the changes up to GitHub.
- Confirm that the change was synchronized to your GitHub repository.
- In the GitHub `practice-repo` repository, 
directly edit your `README.md` file there.
Commit the changes.
- Open up your RStudio `practice-repo` project 
and pull the changes you made on GitHub.

### Dealing with file conflicts between the local and remote

TODO: Image of conflict, indicating what part is from where.

### Exercise: Dealing with merge conflicts

Time: 10 min

- In your 

### Collaborating using Git and GitHub 

```{r image-git-remotes-collaborate, echo=FALSE, fig.cap="Collaborating with others using Git and Github by having a shared central GitHub repository."}
knitr::include_graphics(here::here("images/git-remotes-collaborate.png"))
```

## Summary of session

## Final exercise: Group work

Time: 30 min

For this exercise, you as a group will upload your group project folder to GitHub.
We've already created a team repository for you 
(which you should already have access to).
From this point on you'll use Git and GitHub to collaborate on your project.

- During the R project session's final exercise on the first day, 
you designated a "coordinator" in your group. 
For this task, 
the coordinator needs to link their project to the team's GitHub repository 
and upload (push) their project files to GitHub.
- After the coordinator has done this, 
each team member must "clone" (download) 
the updated project using RStudio's interface
("File -> New Project -> Version Control -> Git").
Then they need to take any files they worked on in their old project folder
and move them into the newly created Git repository.
Then add, commit, and push those file changes to GitHub.
    - You'll likely have to deal with Merge Conflicts at this point. 
    We'll be here to help out.
- Then complete item 5 and its sub-tasks in the [group assignment](assignment.html)
(to jump quickly to the assignment, 
run `r3::open_assignment()` in the RStudio Console).
