# Data visualization {#visualization}

![](https://img.shields.io/badge/document%20status-in%20progress-orange?style=flat-square)

> When in RStudio, quickly jump to this page by using `r3::open_data_visualization()`.

**Session objectives**:

1. Learn and apply the basics of creating publication-quality graphs.
1. Learn about the importance of considering the colours you use in your graphs,
and apply tools that are colour-blind friendly.
1. Learn about and avoid using certain commonly used, 
but inappropriate graphs for presenting results.
1. Create useful graphs such as boxplots, scatterplots, line graphs,
jitter plots, (appropriate) barplots, and 

## Basic principles for creating graphs

**Please take 5 min to read through this section, as well as the next one**
before we go over it together.

Making graphs in R is surprisingly easy and can be done with very little code.
Because of the ease with which to make them,
this gives you time to reason about *why* you are making them,
if the graph is the *most appropriate* for the data or results,
and how you can design your graphs to be as accessible 
and understandable as possible.

To start, here are some tips for making a graph 
(there are excellent online books on this that are included in the 
[resources](resources) chapter:

- Whenever possible or reasonable, show raw data values rather than summaries 
(e.g. means)
- Though commonly used in scientific papers, 
*[avoid barplots]* with means and error bars as they greatly misrepresent the data
(we'll cover why later)
- Use colour to 1) highlight and enhance your message 
and 2) to make the plot visually appealing
- Use a colour-blind friendly palette so the plot is more accessible to others
(more on this later)

[avoid barplots]: https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128

## Basic structure of using ggplot2

ggplot2 is an implementation of the ["Grammar of Graphics"](https://www.springer.com/gp/book/9780387245447) (gg). 
This is a powerful approach to creating plots 
because it provides a set of structured rules (a "grammar") 
that allow you to expressively describe components (or "layers") of a graph.
Because you are able to describe the components,
it makes it easier to then implement those "descriptions" into creating a graph.
There are at least four aspects to using ggplot2 that relate to its "grammar":

- Aesthetics, `aes()`: How data is mapped to the plot, for instance, what
data to put on the x axis, on the y axis, 
and/or whether to use a colour for a variable.
- Geometries, `geom_` functions: The visual representation of the data, as a
layer. This tells ggplot2 how the aesthetics should be visualized.
For instance should they be shown as points, lines, boxes, bins, or bars?
- Scales, `scale_` functions: These control the visual properties of the `geom_` layers.
For instance, to change the colour of dots from red to blue,
or to use a different colour palette entirely.
- Themes, `theme_` functions or `theme()`: 
Directly controls all other aspects of the plot.
For instance, control the size, font, and angle of axis text. 
Or maybe change the thickness or colour of the axis lines.

There is a massive amount of features in ggplot2.
Thankfully, ggplot2 was specifically designed to make it easy to find 
and use its functions and settings using tab auto-completion.
As an example, if you type out `geom_` and then hit tab, 
you will get a list of all the geom's available.
Likewise with `scale_` and all the options inside `theme()`
(e.g. type out `theme(axis.` and then hit tab, 
and a list of theme settings related to the axis will pop up).
ggplot2 also works best with tidy data and with data in the long format.

**Ok, now we'll go over this together**.

## Graph individual variables

Very often you want to get a sense of your data, 
one variable (a column in a data frame) at a time.
You create these plots to see the distribution of a variable
and visually inspect the data for any problems.
There are several ways of plotting continuous variables 
(e.g. weight, height) in ggplot2. 
For discrete variables (e.g. "male" and "female"), 
there is really only one way. 

Ok, let's visually explore our data. 
Open the previously used R Project, 
then open the `visualization-session.R` script in the `R/` folder. 
This script we will use for the code-along, but not for the exercises.
First, let's add this to the top of the script:

```{r}
source(here::here("R/package-loading.R"))
```

Since BMI is a strong risk factor for diabetes, let's check out its distribution.
To show distributions, there are two good geoms: 
`geom_density()` and `geom_histogram()`.

```{r plot-bmi, message=FALSE}
ggplot(NHANES, aes(x = BMI)) +
    geom_density()
ggplot(NHANES, aes(x = BMI)) +
    geom_histogram()
```

It's good practice to always create a new line after the `+`.
We can see that for the most part there is a good distribution with BMI,
though there are several values that are quite large...
some at 80 BMI!

The plots above are for continuous variables, 
but what about for discrete?
Well, sadly, there's really only one: `geom_bar()`.
This isn't a geom for a barplot though! 
This shows the counts of a discrete variable.
There are many discrete variables in NHANES.
Sex is another good variable to examine
and NHANES also has a diabetes variable, 
so let's visualize those:

```{r plot-gender-diabetes}
ggplot(NHANES, aes(x = Gender)) +
    geom_bar()
ggplot(NHANES, aes(x = Diabetes)) +
    geom_bar()
```

We can see that for the most part there is equal numbers of females and males.
And for diabetes, it seems there are some missingness in the dataset.

Let's take a minute to talk about the commonly used barplots with mean and error bars.
In all cases, bar plots should only be used for discrete (categorical) data
and you want to show counts or proportions, not use it for continuous data.
But the commonly used "bar with means and errors" 
plot actually hides the underlying distribution of the data.
To have a better explanation of this,
you can read the article on why to [avoid barplots] after the course. 
The image below, taken from that paper, 
shows briefly why this plot type is not useful. 

(ref:deceptive-barplots) Bars deceive what the data actually looks like. Image source from a [PLoS Biology article](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128).

```{r barplots-deceive, fig.cap="(ref:deceptive-barplots)", echo=FALSE}
knitr::include_graphics(here::here("images/barplots-deceive.png"))
```

If you do want to create a barplot, 
you'll quickly find out that it actually is quite hard to do in ggplot2.
The reason it is difficult to create in ggplot2 is by design:
it's a bad plot to use, so use something else.

## Plotting two variables

Next section is about plotting multiple variables at a time,
in this case, two variables.
There are many more types of "geoms" to use when plotting two variables.
and which one you choose depends on what you are trying to show
or to communicate, and what the data is. 
Usually the variable that you "control or influence" 
(the independent variable) in an experimental setting goes on the x-axis
and the variable that "responds" (the dependent variable)
goes on the y-axis.

When you have *two continuous* variables, some geoms are:

- `geom_point()`, which is to create a standard scatterplot
- `geom_hex()`, which is used to replace `geom_point()` 
when your data is *massive*, since creating points 
for each value in a large dataset can take a long time to plot
- `geom_smooth()`, which applies a "regression-type" line to the data
(using LOESS regression)

Let's check out how BMI may influence cholesterol using a basic scatterplot,
hex plot, and a smoothing line plot:

```{r plot-bmi-chol, message=FALSE}
# Using 2 continuous 
bmi_chol <- ggplot(NHANES, aes(x = BMI, y = TotChol))
# Standard scatter plot
bmi_chol + 
    geom_point()
# Standard scatter plot, but with hexes
bmi_chol + 
    geom_hex()
# Runs a smoothing line with confidence interval
bmi_chol + 
    geom_smooth()
```

Notice how the hex plot changes the colour of the data 
based on how many values are in the area of the plot.

### Two discrete variables

For two discrete variables, there isn't as many options.

```{r plot_2d_discr}
# 2 categorical/discrete
two_categ <- ggplot(NHANES, aes(x = Education, fill = Diabetes)) 

# Stacked
two_categ + 
    geom_bar()
# Side-by-side by using position_dodge for groupings (e.g. fill)
two_categ + 
    geom_bar(position = position_dodge())
```

### Discrete and continuous variables

As with the two continuous variables, there are many options for plotting mixed
data types.

```{r plot_2d_mix}
# Using mixed data
two_mixed <- ggplot(NHANES, aes(x = Diabetes, y = TotChol))

# Standard boxplot
two_mixed + 
    geom_boxplot()
# To remove NA, need to remove from data
# Combine with dplyr:
NHANES %>% 
    filter(!is.na(Diabetes)) %>% 
    ggplot(aes(x = Diabetes, y = TotChol)) +
    geom_boxplot()
# Better than boxplot, show the actual data!
two_mixed + 
    geom_jitter()
# Give more distance between groups
two_mixed + 
    geom_jitter(width = 0.2)
```

### Exercise: Create plots with one or two variables

Time: 10 min

Create an exercise script by typing in the console
`usethis::use_r("exercises-visualizing")`. Copy the code below into that script.
Fill in and complete the code by using either your own data or using the NHANES
dataset to create a plot with:

1. 1 continuous variable.
1. 1 discrete variable.
1. 2 continuous variables.
1. 2 discrete variables.
1. 1 continuous and 1 discrete variable.

```{r 2d-exercise, eval=FALSE}
# See the variables available
names(___)

# 1 continuous
ggplot(___, aes(x = ___)) +
    ___
    
# 1 discrete
ggplot(___, aes(x = ___)) +
    ___

# 2 continuous
ggplot(___, aes(x = ___, y = ___)) +
    ___
    
# 2 discrete
ggplot(___, aes(x = ___, fill = ___)) +
    ___

# 1 continous and 1 discrete
ggplot(___, aes(x = ___, y = ___)) +
    ___
```

<details><summary><strong>Click for a possible solution</strong></summary>
<p>

```{r 2d-answer, eval=FALSE}
# See the variables available
names(NHANES)

# 1 continuous
ggplot(NHANES, aes(x = Testosterone)) +
    geom_density()
    
# 1 discrete
ggplot(NHANES, aes(x = HomeOwn)) +
    geom_bar()

# 2 continuous
ggplot(NHANES, aes(x = BMI, y = BPSysAve)) +
    geom_point()
    
# 2 discrete
ggplot(NHANES, aes(x = SmokeNow, fill = Diabetes)) +
    geom_bar(position = position_dodge())

# 1 continous and 1 discrete
ggplot(NHANES, aes(x = Gender, y = Pulse)) +
    geom_boxplot()
```

</p>
</details>

## Visualizing three or more variables

- `geom_line()`, which is useful when showing data 
that is some way related to a previous state (on the x-axis)

You can also add an additional dimension to the data by using other elements
(colours, size, transparency, etc) of the graph to represent another variable.
This is *NOT* the same thing as using 3-dimensional (e.g. with x, y, z axis)
plots, which should be avoided unless absolutely necessary! Using colours to
represent discrete groups is useful, or for using shading to represent a range
in continuous values.

```{r plot_3d_colour}
# Continuous and discrete
# Note, we can use the pipe %>% to put the data into ggplot
colour_plot_nums <- NHANES %>% 
    ggplot(aes(x = BMI, y = BPSysAve, colour = HomeOwn)) 

# Scatter plot
colour_plot_nums + 
    geom_point()
# Smoothing
colour_plot_nums + 
    geom_smooth()
# Continuous and discrete
colour_plot_mixed <- NHANES %>% 
    ggplot(aes(x = Gender, y = BPSysAve, colour = HomeOwn)) 
# Boxplot
colour_plot_mixed + 
    geom_boxplot()
```

Or add a fourth variable.

```{r plot_4d_lines_shapes}
# Scatter plot with alpha (transparency) or size
colour_plot_nums + 
    geom_point(aes(alpha = Age))
colour_plot_nums + 
    geom_point(aes(size = Age))
# Smoothing plot
colour_plot_nums + 
    geom_smooth(aes(linetype = Diabetes))
```

You can also add another variable dimension by "facetting", which means splitting
the data up by the variable and plot by that variable.

```{r plot_facet}
colour_plot_mixed +
    geom_boxplot() +
    # Cols means to have them side by side (horizontal)
    # vars() is necessary to access variable from dataset
    facet_grid(cols = vars(SurveyYr))
# Or by another variable
colour_plot_mixed +
    geom_boxplot() +
    # Rows means to have them stacked vertically
    facet_grid(cols = vars(SurveyYr), rows = vars(PhysActive))
```

And you can add another geom as a layer on top of the previous one by adding
(`+`) a geom to the next line.

```{r plot_more_layers}
# Three layers
colour_plot_nums + 
    geom_point() +
    geom_smooth() +
    facet_grid(cols = vars(SurveyYr))
```

### Colours: Make your graph more accessible

Colour blindness is common in the population, and red-green colour blindness in
particular affects 8% of men and 0.5% of women. Making your graph more
accessible to people affected by colour blindness will also usually improve the
interpretability of your graphs for all people. For more detail on how colours
look to those with colour-blindness, see this
[documentation](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) 
from the [viridis] package. The viridis colour scheme and R package was
specifically designed to represent data well to all colour visions. There is
also a really good, informative [talk on
YouTube](https://www.youtube.com/watch?v=xAoljeRJ3lU) on this topic.

[viridis]: https://cran.r-project.org/packages=viridis

When using colours, take time to think about what you are trying to convey in
your figure and how your choice of colours will be interpreted. You can use
built-in colour schemes, or set your own. Let's stick to using builtin ones.
There are two, the viridis and the [ColorBrewer] colour schemes. Both are well
designed and are colour-blind friendly.

[ColorBrewer]: https://colorbrewer2.org/

```{r changing_color_schemes}
base_boxplot <- NHANES %>% 
    ggplot(aes(x = HomeOwn, fill = Education)) +
    geom_bar(position = position_dodge()) 

# Add the viridis scheme
base_boxplot +
    # _d() is for discrete. _c() is for continuous.
    scale_fill_viridis_d()
# Use another viridis color scheme
# Ranges from A to E
base_boxplot +
    scale_fill_viridis_d(option = "A")
# Or use the brewer scheme
base_boxplot +
    scale_fill_brewer()
base_boxplot +
    scale_fill_brewer(type = "qual")
```

See all colour palettes for the Brewer palette, use
`RColorBrewer::display.brewer.all()`. If you use a `colour = VariableName` in
`aes()`, you'll need to use `scale_colour_*` (either brewer or viridis).

### Exercise: Create a three (or more) variable plots

Time: 10 min

In the `exercises-visualizing.R` script, add a new Section (`Ctrl-Shift-R`) and
copy the code below into the script. Then, create (with your own data or with
NHANES) several plots with:

1. Two continuous (x, y) and one discrete variables (colour), with another
discrete variable as the facet. (Optionally include another layer, like
smoothing).
2. Three continuous variables (x, y, and colour), using the viridis colour
palette for continuous data.
3. Three discrete variables (x, fill, facet), using the brewer colour palette.

```{r 3d-more-exercise, eval=FALSE}
# 1. Two continuous, discrete, and one facet.
ggplot(___, aes(x = ___, y = ___, colour = ___)) +
    ___ +
    facet_
    # Optional: add another layer

# 2. Three continuous, with viridis
ggplot(___, aes(x = ___, y = ___, colour = ___)) +
    ___ +
    scale_

# 3. Three discrete, with brewer
ggplot(___, aes(x = ___, fill = ___)) +
    ___ +
    facet_ +
    scale_
```

<details><summary><strong>Click for a possible solution</strong></summary>
<p>

```{r 3d-more-answer, eval=FALSE}
# 1. Two continuous, discrete, and one facet.
ggplot(NHANES, aes(x = Height, y = Weight, colour = Gender)) +
    geom_point() +
    facet_grid(rows = vars(Diabetes))
    # Optional: add another layer

# 2. Three continuous, with viridis
ggplot(NHANES, aes(x = Height, y = Weight, colour = Age)) +
    geom_point() +
    scale_colour_viridis_c()

# 3. Three discrete, with brewer
ggplot(NHANES, aes(x = Gender, fill = Education)) +
    geom_bar(position = position_dodge()) +
    facet_grid(cols = vars(Diabetes)) +
    scale_fill_brewer()
```

</p>
</details>

## Titles, axis labels, and themes

There are so so so many options to modify the figure, and they are all basically
contained in the `theme()` function. Search the help documentation using `?theme`
or checking out the [ggplot2 website]. There are way too many customizations
available to show in this session. So we'll instead cover a few of the options
to give you a sense of how to customize, as well as showing some of the built-in
themes (starting with `theme_`).

[ggplot2 website]: https://ggplot2.tidyverse.org/reference/theme.html

```{r plot_themes}
basic_scatterplot <- NHANES %>% 
    ggplot(aes(x = Height, y = Weight, colour = Age)) +
    # use alpha (transparency) since there are so many dots
    geom_point(alpha = 0.5) +
    facet_grid(cols = vars(Gender)) +
    scale_color_viridis_c()

# Some pre-defined themes
basic_scatterplot + theme_bw()
basic_scatterplot + theme_minimal()
basic_scatterplot + theme_classic()
# Adding labels
basic_scatterplot +
    labs(title = "Height and weight by age and gender",
         x = "Height (cm)",
         y = "Weight (kg)")
# Edit specific plot items
basic_scatterplot +
    # theme is good at warning you if something isn't right
    # See ?theme for a full list of possible options
    theme(
        # background items must use element_rect
        # panel is the base/bottom layer that all other layers add to
        panel.background = element_rect(fill = "pink"),
        # strip is the section showing the facets
        strip.background = element_rect(fill = "red"),
        # line items must use element_line
        # axis is, well the axis
        axis.line = element_line(colour = "grey50", size = 0.5),
        # text items must use element_text
        # legend is the key when using fill, colour, size, etc
        legend.text = element_text(family = "sans", size = 20),
        # use element_blank to remove
        axis.ticks = element_blank()
    )
```

## Saving the plot

Now, if you want to save the plot, you can do that like this:

```{r, eval=FALSE}
plot_to_save <- NHANES %>% 
    ggplot(aes(x = Age, y = BMI)) +
    geom_point()
ggsave("plot_to_save.pdf", plot_to_save, width = 7, height = 5)
```

## Final exercise: Group work

Time: 30 min

In your groups, start exploring your data by making ggplot2 graphs.
Ultimately, your goal as a group is to complete item 6 of the [assignment](assignment).
It's a good idea to distribute exploration to each group member,
so that each member gets practice making ggplot2 graphs.
Take about 10-15 min to do these tasks:

- Each member create an R script in the `R/` folder
to start creating visually exploring the data.
Name these new files with your name and `-exploring.R`.
- Add, commit, and push these files to your GitHub repository.
- Find out what some visually interesting
and insightful plots are that you could show in the presentation 
and in the report.

Then with the remaining time, as a group:

- Decide what graphs to include in the report and presentation.
- Complete item 6 of the assignment by creating an R script that will create those figures.
- Add, commit, and push the new file to GitHub.
- Save these figures in the `doc/images/` folder.
- Add, commit, and push the images to GitHub.
