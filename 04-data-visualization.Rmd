# Data visualization {#visualization}

![](https://img.shields.io/badge/document%20status-in%20progress-orange?style=flat-square)

> When in RStudio, quickly jump to this page by using `r3::open_data_visualization()`.

**Session objectives**:

1. Learn and apply the basics of creating publication-quality graphs.
1. Learn about the importance of considering the colours you use in your graphs,
and apply tools that are colour-blind friendly.
1. Learn about and avoid using certain commonly used, 
but inappropriate graphs for presenting results.
1. Create useful graphs such as boxplots, scatterplots, line graphs,
jitter plots, (appropriate) barplots, and 

## Basic principles for creating graphs

**Please take ~10 min to read through this section, as well as the next one**
before we go over it together.

Making graphs in R is surprisingly easy and can be done with very little code.
Because of the ease with which to make them,
this gives you time to reason about *why* you are making them,
if the graph is the *most appropriate* for the data or results,
and how you can design your graphs to be as accessible 
and understandable as possible.

To start, here are some tips for making a graph 
(there are excellent online books on this that are included in the 
[resources](resources) chapter:

- Whenever possible or reasonable, show raw data values rather than summaries 
(e.g. means)
- Though commonly used in scientific papers, 
*[avoid barplots]* with means and error bars as they greatly misrepresent the data
(we'll cover why later)
- Use colour to 1) highlight and enhance your message 
and 2) to make the plot visually appealing
- Use a colour-blind friendly palette so the plot is more accessible to others
(more on this later)

[avoid barplots]: https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128

## Basic structure of using ggplot2

ggplot2 is an implementation of the ["Grammar of Graphics"](https://www.springer.com/gp/book/9780387245447) (gg). 
This is a powerful approach to creating plots 
because it provides a set of structured rules (a "grammar") 
that allow you to expressively describe components (or "layers") of a graph.
Because you are able to describe the components,
it makes it easier to then implement those "descriptions" into creating a graph.
There are at least four aspects to using ggplot2 that relate to its "grammar":

- Aesthetics, `aes()`: How data is mapped to the plot, for instance, what
data to put on the x axis, on the y axis, 
and/or whether to use a colour for a variable.
- Geometries, `geom_` functions: The visual representation of the data, as a
layer. This tells ggplot2 how the aesthetics should be visualized.
For instance should they be shown as points, lines, boxes, bins, or bars?
- Scales, `scale_` functions: These control the visual properties of the `geom_` layers.
For instance, to change the colour of dots from red to blue,
or to use a different colour palette entirely.
- Themes, `theme_` functions or `theme()`: 
Directly controls all other aspects of the plot.
For instance, control the size, font, and angle of axis text. 
Or maybe change the thickness or colour of the axis lines.

There is a massive amount of features in ggplot2.
Thankfully, ggplot2 was specifically designed to make it easy to find 
and use its functions and settings using tab auto-completion.
As an example, if you type out `geom_` and then hit tab, 
you will get a list of all the geom's available.
Likewise with `scale_` and all the options inside `theme()`
(e.g. type out `theme(axis.` and then hit tab, 
and a list of theme settings related to the axis will pop up).
ggplot2 also works best with tidy data and with data in the long format.

So, why do we teach ggplot2 and not base R plotting?
Base R plotting functionality is quite good and you can make really nice,
publication-quality graphs.
However, there are several major limitations to base R plots from a beginner
and a user-interface perspective. 
These limitations are due to the fact that base R plotting was developed:

- By different people over time periods of time
- By people who were/are mostly in statistics and math
- By people who (generally) don't have training in principles of
software user-design, user-interface, or engineering
- Without a strong "design philosophy"
- During a time when auto-completion didn't really exist or was sub-optimal
(so short function and object names were important)

Because of this, base R graphics *generally*:

- Have inconsistent in function and argument naming and documentation
- Don't place priority on user-friendly documentation 
that is accessible to a broad range of people
- Don't have help documentation that is designed with beginners in mind
- Are built similar to painting on a canvas: 
If you make a mistake, you need to start over (e.g. restart R)

One the other hand, ggplot2:

- Has excellent documentation for help and learning
- Has a strong design philosophy that makes it easier to use
- Works in "layers", so you don't have to start over if you make a mistake
- Works very well with auto-completion
- Function and argument naming is consistent and *descriptive* (in plain English)

These are the reasons we teach and use ggplot2.

**Ok, now we'll go over this together**.

## Graph individual variables

Very often you want to get a sense of your data, 
one variable (a column in a data frame) at a time.
You create these plots to see the distribution of a variable
and visually inspect the data for any problems.
There are several ways of plotting continuous variables 
(e.g. weight, height) in ggplot2. 
For discrete variables (e.g. "male" and "female"), 
there is really only one way. 

You may notice that since the [data wrangling chapter](wrangling),
we used the word "column" to describe the columns in the data frame,
but now we're saying "variable".
There's a reason for this: ggplot2 really only works with tidy data.
And if we recall from the definition of tidy data,
it is made up of "variables" and "observations" for columns 
and rows of a data frame.
To us, a "variable" is some that we are interested analyzing or visualizing, 
and that contains only values relevant to that measurement
(e.g. a `Weight` variable must only contain values for weight).
The NHANES dataset is already pretty tidy:
Rows are participants at the survey year,
columns are the variables that were measured.
So, from now on, we called them "variables".

Ok, let's visually explore our data. 
Open the previously used R Project, 
then open the `visualization-session.R` script in the `R/` folder. 
This script we will use for the code-along, but not for the exercises.
First, let's add this to the top of the script:

```{r}
source(here::here("R/package-loading.R"))
```

Since BMI is a strong risk factor for diabetes, let's check out its distribution.
To show distributions, there are two good geoms: 
`geom_density()` and `geom_histogram()`.

```{r plot-bmi, message=FALSE}
ggplot(NHANES, aes(x = BMI)) +
    geom_density()
ggplot(NHANES, aes(x = BMI)) +
    geom_histogram()
```

It's good practice to always create a new line after the `+`.
We can see that for the most part there is a good distribution with BMI,
though there are several values that are quite large...
some at 80 BMI!

The plots above are for continuous variables, 
but what about for discrete?
Well, sadly, there's really only one: `geom_bar()`.
This isn't a geom for a barplot though! 
This shows the counts of a discrete variable.
There are many discrete variables in NHANES.
Sex is another good variable to examine
and NHANES also has a diabetes variable, 
so let's visualize those. 
But first, let's fix the `Gender` column to be called `Sex`.

```{r fix-sex-column}
nhanes_tidied <- NHANES %>% 
    rename(Sex = Gender)
```

Now, let's visualize them:

```{r}
ggplot(nhanes_tidied, aes(x = Sex)) +
    geom_bar()
ggplot(nhanes_tidied, aes(x = Diabetes)) +
    geom_bar()
```

We can see that for the most part there is equal numbers of females and males.
And for diabetes, it seems there are some missingness in the dataset.
Since diabetes status is an important variable for us,
let's remove all missing values right now.

```{r remove-missing-diabetes}
nhanes_tidied2 <- nhanes_tidied %>% 
    filter(!is.na(Diabetes))
```

Let's take a minute to talk about the commonly used barplots with mean and error bars.
In all cases, bar plots should only be used for discrete (categorical) data
and you want to show counts or proportions, not use it for continuous data.
But the commonly used "bar with means and errors" 
plot actually hides the underlying distribution of the data.
To have a better explanation of this,
you can read the article on why to [avoid barplots] after the course. 
The image below, taken from that paper, 
shows briefly why this plot type is not useful. 

(ref:deceptive-barplots) Bars deceive what the data actually looks like. Image source from a [PLoS Biology article](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128).

```{r barplots-deceive, fig.cap="(ref:deceptive-barplots)", echo=FALSE}
knitr::include_graphics(here::here("images/barplots-deceive.png"))
```

If you do want to create a barplot, 
you'll quickly find out that it actually is quite hard to do in ggplot2.
The reason it is difficult to create in ggplot2 is by design:
it's a bad plot to use, so use something else.

## Plotting two variables

Next section is about plotting multiple variables at a time,
in this case, two variables.
There are many more types of "geoms" to use when plotting two variables.
and which one you choose depends on what you are trying to show
or to communicate, and what the data is. 
Usually the variable that you "control or influence" 
(the independent variable) in an experimental setting goes on the x-axis
and the variable that "responds" (the dependent variable)
goes on the y-axis.

When you have *two continuous* variables, some geoms are:

- `geom_point()`, which is to create a standard scatterplot
- `geom_hex()`, which is used to replace `geom_point()` 
when your data is *massive*, since creating points 
for each value in a large dataset can take a long time to plot
- `geom_smooth()`, which applies a "regression-type" line to the data
(using LOESS regression)

Let's check out how BMI may influence cholesterol using a basic scatterplot,
hex plot, and a smoothing line plot:

```{r plot-bmi-chol, message=FALSE}
# Using 2 continuous 
bmi_chol <- ggplot(nhanes_tidied2, aes(x = BMI, y = TotChol))
# Standard scatter plot
bmi_chol + 
    geom_point()
# Standard scatter plot, but with hexes
bmi_chol + 
    geom_hex()
# Runs a smoothing line with confidence interval
bmi_chol + 
    geom_smooth()
```

Notice how the hex plot changes the colour of the data 
based on how many values are in the area of the plot.

### Two discrete variables

Sadly, for two discrete data, 
there are as many options available without major data wrangling. 
The most useful geom for this is `geom_bar()` like before 
but with an added variable.
Because `geom_bar()` has a "fill" (coloured inside), 
we can change that fill based on a variable.
So let's see what the difference in diabetes status is between sexes.

```{r}
# 2 categorical/discrete
# (We can pipe data into ggplot)
two_discrete <- nhanes_tidied2 %>% 
    ggplot(aes(x = Diabetes, fill = Sex)) 

# Stacked
two_discrete + 
    geom_bar()
```

By default, `geom_bar()` will make fill groups stacked on top of each other.
For this case, it isn't really that useful.
So let's instead have them side by side. 
For that, we need to use the `position` argument with a function called
`position_dodge()`.
This new function takes the fill grouping variable and "dodges" them 
(moves them) to be side by side.

```{r}
two_discrete + 
    geom_bar(position = position_dodge())
```

### Discrete and continuous variables

When the variable types are mixed (continuous and discrete),
there are many more geoms available to use.
A couple good ones are:

- `geom_boxplot()`, which makes boxplots that show the median 
and a measure of range in the data. 
Boxplots are generally pretty good at showing the spread of data.
- `geom_jitter()`, which makes a type of "scatter" plot, 
but for discrete and continuous variables. 
A useful argument to `geom_jitter()` is called `width`,
which controls how wide the jittered points go out from the center line.
This plot is much better than the boxplot since it shows the *actual data*,
and not summaries like boxplot does.
When you have lots of data however, it isn't very good.
- `geom_violin()`, which shows a density distribution (like `geom_density()`).
This geom is great when there is a lot of data 
and `geom_jitter()` is just a mass of dots.

Let's see how BMI differs between those with or without diabetes.

```{r}
# Using mixed data
two_mixed <- nhanes_tidied2 %>% 
    ggplot(aes(x = Diabetes, y = BMI))

# Standard boxplot
two_mixed + 
    geom_boxplot()
# Better than boxplot, show the actual data!
two_mixed + 
    geom_jitter()
# Give more distance between groups
two_mixed + 
    geom_jitter(width = 0.2)
# Show the distribution with a voilin plot
two_mixed + 
    geom_violin()
```

The violin plot kind of looks like two stingrays, eh?

## Exercise: Create plots with one or two variables

Time: 15 min

Create an exercise script by typing in the Console `usethis::use_r("exercises-visualizing")`.
Copy and paste the below code into that script.
Complete as many tasks as you can below.

1. Like we did above, remove rows that have missing diabetes 
and rename `Gender` to `Sex`. 
Reminder, use `!` to invert a logic condition 
(from `TRUE` to `FALSE` and vice versa, e.g. for keeping non-missing).
We do this again in this script to make the script self-contained.
2. Using `geom_histogram()`, find out what the distribution is the below variables.
What are most peoples ages for these two variables?
    a. `Age` (participants age at collection)
    b. `DiabetesAge` (age of diabetes diagnosis)
3. Using `geom_bar()`, find out how many people are in each of these discrete variables.
What can you say about most people for these variables?
    a. `SmokeNow` (current smoking status)
    b. `PhysActive` (does moderate to vigorous physical activity)
4. Using `geom_hex()`, find out how BMI relates to the two blood pressure variables.
For most people, how much BMI and blood pressure do they have? 
Do you notice anything about the data from the plots?
    a. `BPSysAve` (average systolic blood pressure)
    b. `BPDiaAve` (average diastolic blood pressure)
5. Using `geom_bar()`, find out how `PhysActive` those with or without `Diabetes` are.
Put `Diabetes` on the x-axis.
What can you say based on the data? 
Note the differences in missingness between groups.
Don't forget to use `position_dodge()` in the `position` argument.
6. Using `geom_violin()`, 
find how `Poverty` levels are different for those with or without `Diabetes`.
Put `Diabetes` on the x-axis.
Looking at the distributions, 
what can you conclude about how poverty may influence diabetes status?
    - `Poverty`, which is a ratio between income and a poverty threshold. 
    Smaller numbers mean higher poverty.

```{r exercise-2-var-plots, eval=FALSE}
# 1. Remove missing diabetes, rename to Sex
nhanes_tidy <- NHANES %>% 
    # Filter rows
    ___(___(___)) %>% 
    # Rename column
    ___(___ = ___)

# 2a. Distribution of Age
ggplot(___, aes(x = ___)) +
    ___()
    
# 2b. Distribution of DiabetesAge
ggplot(___, aes(x = ___)) +
    ___()

# 3a. Number of people who SmokeNow
ggplot(___, aes(x = ___)) +
    ___()

# 3a. Number of people who are PhysActive
ggplot(___, aes(x = ___)) +
    ___()

# 4a. BMI relation to systolic blood pressure
ggplot(___, aes(x = ___, y = ___)) +
    ___()

# 4b. BMI relation to diastolic blood pressure
ggplot(___, aes(x = ___, y = ___)) +
    ___()
    
# 5. Physically active people with or without diabetes
ggplot(___, aes(x = ___, fill = ___)) +
    ___(___ = ___())

# 6. Poverty levels between those with or without diabetes
ggplot(___, aes(x = ___, y = ___)) +
    ___()
```

<details><summary><strong>Click for a possible solution</strong></summary>
<p>

```{r answer-2-var-plots, eval=FALSE}
# 1. Remove missing diabetes, rename to Sex
nhanes_tidy <- NHANES %>% 
    # Filter rows
    filter(!is.na(Diabetes)) %>% 
    # Rename column
    rename(Sex = Gender)

# 2a. Distribution of Age
ggplot(nhanes_tidy, aes(x = Age)) +
    geom_histogram()
    
# 2b. Distribution of DiabetesAge
ggplot(nhanes_tidy, aes(x = DiabetesAge)) +
    geom_histogram()

# 3a. Number of people who SmokeNow
ggplot(nhanes_tidy, aes(x = SmokeNow)) +
    geom_bar()

# 3a. Number of people who are PhysActive
ggplot(nhanes_tidy, aes(x = PhysActive)) +
    geom_bar()

# 4a. BMI relation to systolic blood pressure
ggplot(nhanes_tidy, aes(x = BMI, y = BPSysAve)) +
    geom_hex()

# 4b. BMI relation to diastolic blood pressure
ggplot(nhanes_tidy, aes(x = BMI, y = BPDiaAve)) +
    geom_hex()
    
# 5. Physically active people with or without diabetes
ggplot(nhanes_tidy, aes(x = Diabetes, fill = PhysActive)) +
    geom_bar(position = position_dodge())

# 6. Poverty levels between those with or without diabetes
ggplot(nhanes_tidy, aes(x = Diabetes, y = Poverty)) +
    geom_violin()
```

</p>
</details>

## Visualizing three or more variables

- `geom_line()`, which is useful when showing data 
that is some way related to a previous state (on the x-axis)

You can also add an additional dimension to the data by using other elements
(colours, size, transparency, etc) of the graph to represent another variable.
This is *NOT* the same thing as using 3-dimensional (e.g. with x, y, z axis)
plots, which should be avoided unless absolutely necessary! Using colours to
represent discrete groups is useful, or for using shading to represent a range
in continuous values.

```{r plot_3d_colour}
# Continuous and discrete
# Note, we can use the pipe %>% to put the data into ggplot
colour_plot_nums <- NHANES %>% 
    ggplot(aes(x = BMI, y = BPSysAve, colour = HomeOwn)) 

# Scatter plot
colour_plot_nums + 
    geom_point()
# Smoothing
colour_plot_nums + 
    geom_smooth()
# Continuous and discrete
colour_plot_mixed <- NHANES %>% 
    ggplot(aes(x = Gender, y = BPSysAve, colour = HomeOwn)) 
# Boxplot
colour_plot_mixed + 
    geom_boxplot()
```

Or add a fourth variable.

```{r plot_4d_lines_shapes}
# Scatter plot with alpha (transparency) or size
colour_plot_nums + 
    geom_point(aes(alpha = Age))
colour_plot_nums + 
    geom_point(aes(size = Age))
# Smoothing plot
colour_plot_nums + 
    geom_smooth(aes(linetype = Diabetes))
```

You can also add another variable dimension by "facetting", which means splitting
the data up by the variable and plot by that variable.

```{r plot_facet}
colour_plot_mixed +
    geom_boxplot() +
    # Cols means to have them side by side (horizontal)
    # vars() is necessary to access variable from dataset
    facet_grid(cols = vars(SurveyYr))
# Or by another variable
colour_plot_mixed +
    geom_boxplot() +
    # Rows means to have them stacked vertically
    facet_grid(cols = vars(SurveyYr), rows = vars(PhysActive))
```

And you can add another geom as a layer on top of the previous one by adding
(`+`) a geom to the next line.

```{r plot_more_layers}
# Three layers
colour_plot_nums + 
    geom_point() +
    geom_smooth() +
    facet_grid(cols = vars(SurveyYr))
```

### Colours: Make your graph more accessible

Colour blindness is common in the population, and red-green colour blindness in
particular affects 8% of men and 0.5% of women. Making your graph more
accessible to people affected by colour blindness will also usually improve the
interpretability of your graphs for all people. For more detail on how colours
look to those with colour-blindness, see this
[documentation](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) 
from the [viridis] package. The viridis colour scheme and R package was
specifically designed to represent data well to all colour visions. There is
also a really good, informative [talk on
YouTube](https://www.youtube.com/watch?v=xAoljeRJ3lU) on this topic.

[viridis]: https://cran.r-project.org/packages=viridis

When using colours, take time to think about what you are trying to convey in
your figure and how your choice of colours will be interpreted. You can use
built-in colour schemes, or set your own. Let's stick to using builtin ones.
There are two, the viridis and the [ColorBrewer] colour schemes. Both are well
designed and are colour-blind friendly.

[ColorBrewer]: https://colorbrewer2.org/

```{r changing_color_schemes}
base_boxplot <- NHANES %>% 
    ggplot(aes(x = HomeOwn, fill = Education)) +
    geom_bar(position = position_dodge()) 

# Add the viridis scheme
base_boxplot +
    # _d() is for discrete. _c() is for continuous.
    scale_fill_viridis_d()
# Use another viridis color scheme
# Ranges from A to E
base_boxplot +
    scale_fill_viridis_d(option = "A")
# Or use the brewer scheme
base_boxplot +
    scale_fill_brewer()
base_boxplot +
    scale_fill_brewer(type = "qual")
```

See all colour palettes for the Brewer palette, use
`RColorBrewer::display.brewer.all()`. If you use a `colour = VariableName` in
`aes()`, you'll need to use `scale_colour_*` (either brewer or viridis).

### Exercise: Create a three (or more) variable plots

Time: 10 min

In the `exercises-visualizing.R` script, add a new Section (`Ctrl-Shift-R`) and
copy the code below into the script. Then, create (with your own data or with
NHANES) several plots with:

1. Two continuous (x, y) and one discrete variables (colour), with another
discrete variable as the facet. (Optionally include another layer, like
smoothing).
2. Three continuous variables (x, y, and colour), using the viridis colour
palette for continuous data.
3. Three discrete variables (x, fill, facet), using the brewer colour palette.

```{r 3d-more-exercise, eval=FALSE}
# 1. Two continuous, discrete, and one facet.
ggplot(___, aes(x = ___, y = ___, colour = ___)) +
    ___ +
    facet_
    # Optional: add another layer

# 2. Three continuous, with viridis
ggplot(___, aes(x = ___, y = ___, colour = ___)) +
    ___ +
    scale_

# 3. Three discrete, with brewer
ggplot(___, aes(x = ___, fill = ___)) +
    ___ +
    facet_ +
    scale_
```

<details><summary><strong>Click for a possible solution</strong></summary>
<p>

```{r 3d-more-answer, eval=FALSE}
# 1. Two continuous, discrete, and one facet.
ggplot(NHANES, aes(x = Height, y = Weight, colour = Gender)) +
    geom_point() +
    facet_grid(rows = vars(Diabetes))
    # Optional: add another layer

# 2. Three continuous, with viridis
ggplot(NHANES, aes(x = Height, y = Weight, colour = Age)) +
    geom_point() +
    scale_colour_viridis_c()

# 3. Three discrete, with brewer
ggplot(NHANES, aes(x = Gender, fill = Education)) +
    geom_bar(position = position_dodge()) +
    facet_grid(cols = vars(Diabetes)) +
    scale_fill_brewer()
```

</p>
</details>

## Titles, axis labels, and themes

There are so so so many options to modify the figure, and they are all basically
contained in the `theme()` function. Search the help documentation using `?theme`
or checking out the [ggplot2 website]. There are way too many customizations
available to show in this session. So we'll instead cover a few of the options
to give you a sense of how to customize, as well as showing some of the built-in
themes (starting with `theme_`).

[ggplot2 website]: https://ggplot2.tidyverse.org/reference/theme.html

```{r plot_themes}
basic_scatterplot <- NHANES %>% 
    ggplot(aes(x = Height, y = Weight, colour = Age)) +
    # use alpha (transparency) since there are so many dots
    geom_point(alpha = 0.5) +
    facet_grid(cols = vars(Gender)) +
    scale_color_viridis_c()

# Some pre-defined themes
basic_scatterplot + theme_bw()
basic_scatterplot + theme_minimal()
basic_scatterplot + theme_classic()
# Adding labels
basic_scatterplot +
    labs(title = "Height and weight by age and gender",
         x = "Height (cm)",
         y = "Weight (kg)")
# Edit specific plot items
basic_scatterplot +
    # theme is good at warning you if something isn't right
    # See ?theme for a full list of possible options
    theme(
        # background items must use element_rect
        # panel is the base/bottom layer that all other layers add to
        panel.background = element_rect(fill = "pink"),
        # strip is the section showing the facets
        strip.background = element_rect(fill = "red"),
        # line items must use element_line
        # axis is, well the axis
        axis.line = element_line(colour = "grey50", size = 0.5),
        # text items must use element_text
        # legend is the key when using fill, colour, size, etc
        legend.text = element_text(family = "sans", size = 20),
        # use element_blank to remove
        axis.ticks = element_blank()
    )
```

## Saving the plot

Now, if you want to save the plot, you can do that like this:

```{r, eval=FALSE}
plot_to_save <- NHANES %>% 
    ggplot(aes(x = Age, y = BMI)) +
    geom_point()
ggsave("plot_to_save.pdf", plot_to_save, width = 7, height = 5)
```

## Final exercise: Group work

Time: 30 min

In your groups, start exploring your data by making ggplot2 graphs.
Ultimately, your goal as a group is to complete item 6 of the [assignment](assignment).
It's a good idea to distribute exploration to each group member,
so that each member gets practice making ggplot2 graphs.
Take about 10-15 min to do these tasks:

- Each member create an R script in the `R/` folder
to start creating visually exploring the data.
Name these new files with your name and `-exploring.R`.
- Add, commit, and push these files to your GitHub repository.
- Find out what some visually interesting
and insightful plots are that you could show in the presentation 
and in the report.

Then with the remaining time, as a group:

- Decide what graphs to include in the report and presentation.
- Complete item 6 of the assignment by creating an R script that will create those figures.
- Add, commit, and push the new file to GitHub.
- Save these figures in the `doc/images/` folder.
- Add, commit, and push the images to GitHub.
