{
  "hash": "dbaac8f84e74586823d2e8ecc04be799",
  "result": {
    "markdown": "# Data management and wrangling {#sec-wrangling}\n\n\n\n\n\n<!-- TODO: Add an introduction here -->\n\n**Session objectives**:\n\n<!-- TODO: Revise objectives to fit how I did it in advanced -->\n\n1.  Learn the difference between \"messy\" and \"tidy\" data, including how\n    to create tidy data to simplify your analysis.\n2.  Perform simple transformations and subsetting of datasets, such as:\n    -   Subset specific columns and rows of a dataset, with\n        `filter()`and `select()`.\n    -   Sort rows of a dataset by a specific column, with `arrange()`.\n    -   Create new or transform existing columns in a dataset, with\n        `mutate()`.\n    -   Calculate simple data summaries, with `summarise()`.\n3.  Learn about and apply the \"split-apply-combine\" method of analyses,\n    with `group_by()` and `summarise()`.\n4.  Write \"tidier\" and more readable code by using the pipe (`%>%`)\n    operator.\n\n## \"Messy\" vs. \"tidy\" data\n\n::: {.callout-note collapse=\"true\"}\n## Instructor note\n\nThis session usually takes a fair amount of time relative to the other\nsessions. The R Markdown session is right afterwards and since it\nusually is done quicker than other sessions, it's fine if this session\ntakes up time in the R Markdown session.\n\nFor the reading section, emphasize the characteristics of a \"tidy\"\ndataset.\n:::\n\n::: callout-note\n## Reading task: \\~10 minutes\n\nThe concept of \"tidy\" data was popularized in an\n[article](https://www.jstatsoft.org/v59/i10/paper) by Hadley Wickham and\ndescribed in more detail in the [Tidy Data\nchapter](https://r4ds.had.co.nz/tidy-data.html) of the *R for Data\nScience* online book. Before we continue with tidy data, we need to\ncover something that is related to the concept of \"tidy\" and that has\nalready come up in this course: the `{tidyverse}`. The `{tidyverse}` is\nan ecosystem of R packages that are designed to work well together, that\nall follow a strong \"[design philosophy](https://design.tidyverse.org/)\"\nand common [style guide](https://style.tidyverse.org/). This makes\ncombining these packages in the tidyverse much easier. We teach the\ntidyverse because of these above mentioned reasons.\n\nOk, back to \"tidy data\". A tidy dataset is when:\n\n-   Each variable has its own column (e.g. \"Body Weight\").\n-   Each observation has its own row (e.g. \"Person\").\n-   Each value has its own cell (e.g. \"Body weight for a person at a\n    specific date\").\n\nTake a look at the example \"tidy\" and \"messy\" data frames (also called\n\"tibbles\" in the tidyverse) below. Think about why each may be\nconsidered \"tidy\" or \"messy\". What do you notice between the tidy\nversions and the messier versions?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Datasets come from tidyr\n# Tidy:\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <int>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\n\n```{.r .cell-code}\n# Partly tidy:\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 12 × 4\n#>    country      year type            count\n#>    <chr>       <int> <chr>           <int>\n#>  1 Afghanistan  1999 cases             745\n#>  2 Afghanistan  1999 population   19987071\n#>  3 Afghanistan  2000 cases            2666\n#>  4 Afghanistan  2000 population   20595360\n#>  5 Brazil       1999 cases           37737\n#>  6 Brazil       1999 population  172006362\n#>  7 Brazil       2000 cases           80488\n#>  8 Brazil       2000 population  174504898\n#>  9 China        1999 cases          212258\n#> 10 China        1999 population 1272915272\n#> 11 China        2000 cases          213766\n#> 12 China        2000 population 1280428583\n```\n:::\n\n```{.r .cell-code}\n# Messier:\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 6 × 3\n#>   country      year rate             \n#>   <chr>       <int> <chr>            \n#> 1 Afghanistan  1999 745/19987071     \n#> 2 Afghanistan  2000 2666/20595360    \n#> 3 Brazil       1999 37737/172006362  \n#> 4 Brazil       2000 80488/174504898  \n#> 5 China        1999 212258/1272915272\n#> 6 China        2000 213766/1280428583\n```\n:::\n\n```{.r .cell-code}\n# Messy:\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <int>  <int>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258 213766\n```\n:::\n\n```{.r .cell-code}\n# Messy:\ntable4b\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 3 × 3\n#>   country         `1999`     `2000`\n#>   <chr>            <int>      <int>\n#> 1 Afghanistan   19987071   20595360\n#> 2 Brazil       172006362  174504898\n#> 3 China       1272915272 1280428583\n```\n:::\n:::\n\n\nThe \"most\" tidy version is `table1` as each column describes their\nvalues (e.g. population is population size), each row is unique (e.g.\nfirst row is for values from Afghanistan from 1999), and each cell is an\nexplicit value representative of its column and row.\n\n`table2` is a \"long\" version of `table1` so it is partly \"tidy\", but it\ndoesn't satisfy the rule that each variable has a column, since `count`\nrepresents both cases and population size.\n\nOn the other hand, `table3` is messy because the `rate` column values\nare a composite of two other column values (cases and population), when\nit should be a single number (a percent). Both `table4a` and `table4b`\nhave columns with ambiguous values inside. For example, you can't tell\nfrom the data what the values in the `1999` column contain.\n\nTidy data has a few notable benefits:\n\n1.  Time spent preparing your data to be tidy from the beginning can\n    save days of added work and frustration in the long run.\n2.  \"Tidy data\" is a conceptual framework that allows you to easily\n    build off and wrangle (i.e. \"manipulate\", \"clean up\", \"manage\") data\n    in simpler and easy-to-interpret ways, especially when used within\n    the framework of the tidyverse.\n\nThe concept of tidy data also gives rise to \"tidy code\" for wrangling.\nBy using \"verbs\" (R functions) and chaining them together in \"sentences\"\n(in a sequential pipeline), you can construct meaningful and readable\ncode that describes in plainer English what you are doing to the data.\nThis is one simple way that you can enhance the reproducibility of your\ncode.\n:::\n\n## Managing and working with data in R\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nAfter they read it, go over and emphasize the functions shown in the\ntable that we will be teaching.\n:::\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nWhen working with data, there are a few principles to follow:\n\n-   You should always save your original raw dataset in the `data-raw/`\n    folder.\n    -   *Note*: Whether or not you save data to `data-raw/` depends on\n        how you collected the data and how many collaborators are on\n        your team. You may end up storing and processing the data in\n        another folder as a project of its own.\n-   **Never** edit your raw data directly and save it in a separate\n    location.\n-   Only work with your raw data using R code. *Don't manually edit it*.\n    Manual editing doesn't leave a history of what you've done to it, so\n    you can't go back and see what you've done. Always keep a history of\n    any changes you've made to the data, preferably by using R code.\n-   Save the edited data as another dataset and store it in the `data/`\n    folder.\n\nWhen wrangling your data with R code, make sure to:\n\n-   Document what you did to your data and why you did it, to help you\n    remember later on (by using hashes to indicate comments and non-code\n    text).\n-   Write the code in a way that is as descriptive as possible and is\n    readable enough to understand what is being done to the data.\n-   Keep the code simple: Don't be clever, be clear. Clear code is\n    easier to understand than clever and sometimes overly-complex code.\n\nIn data wrangling, most tasks can be expressed by a few simple \"verbs\"\n(actions). Wrangling here refers to maneuvering, managing, controlling,\nand turning your data around to clean it up, better understand it, and\nprepare it for later analyses. The table below lists some common \"verbs\"\nfrom the `{dplyr}` package that come from the `{tidyverse}`:\n\n| Task                        | Example                                                                   | Function                        |\n|:----------------------------|:--------------------------------------------------------------------------|:--------------------------------|\n| Select columns              | Remove data entry columns such as the person's name who entered the data. | `select()`                      |\n| Rename columns              | Changing a column name from 'Q1' to 'participant_name'.                   | `rename()`                      |\n| Transform or modify columns | Multiplying or taking the log of a column's values.                       | `mutate()`                      |\n| Subset/filter rows          | Keeping rows with glucose values above 4.                                 | `filter()`                      |\n| Sort rows                   | Show rows with the smallest value at the top.                             | `arrange()`                     |\n| Calculate summaries         | Calculating the maximum, median, and minimum age.                         | ,                               |\n| Run code by a group         | Calculate means of age by males and females.                              | `group_by()` with `summarise()` |\n\n: List of common data wrangling tasks, along with an example and the\nfunction used for the wrangling.\n\n**Tip**: Sometimes you need to do some complicated wrangling to get your\ndata \"in shape\" for later analyses. To save some time, you could save\nthe wrangled data as an \"output\" dataset in the `data/` folder. That\nway, you can easily use it again later rather than having to run the\nwrangling code every time you want to work with the data.\n:::\n\n## Load the packages and dataset\n\nWe're going to use the US\n[NHANES](https://www.cdc.gov/nchs/nhanes/index.htm) dataset to\ndemonstrate some wrangling functions. There is a R package called\n`{NHANES}` that contains a teaching version of the original dataset, so\nwe'll use that for this course.\n\nFirst, make sure that you have the `LearningR` R Project open. Second,\nopen the `R/learning.R` script and write code to load the `{NHANES}`\npackage. It should look like this now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(NHANES)\n```\n:::\n\n\nThere are many ways of loading in data into R. This method loads data\nthat is included in a package, in this case `{NHANES}`. We will cover\nhow to load a dataset from a file at the end of this session.\n\nThen, below the `library()`, let's take a `glimpse()` at the NHANES\ndataset. Run this function by hitting `Alt-Enter` while the cursor is on\nthe code to send it from the script to the R Console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Briefly glimpse contents of dataset\nglimpse(NHANES)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> Rows: 10,000\n#> Columns: 76\n#> $ ID               <int> 51624, 51624, 51624, 51625, 51630, 51638,…\n#> $ SurveyYr         <fct> 2009_10, 2009_10, 2009_10, 2009_10, 2009_…\n#> $ Gender           <fct> male, male, male, male, female, male, mal…\n#> $ Age              <int> 34, 34, 34, 4, 49, 9, 8, 45, 45, 45, 66, …\n#> $ AgeDecade        <fct>  30-39,  30-39,  30-39,  0-9,  40-49,  0-…\n#> $ AgeMonths        <int> 409, 409, 409, 49, 596, 115, 101, 541, 54…\n#> $ Race1            <fct> White, White, White, Other, White, White,…\n#> $ Race3            <fct> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ Education        <fct> High School, High School, High School, NA…\n#> $ MaritalStatus    <fct> Married, Married, Married, NA, LivePartne…\n#> $ HHIncome         <fct> 25000-34999, 25000-34999, 25000-34999, 20…\n#> $ HHIncomeMid      <int> 30000, 30000, 30000, 22500, 40000, 87500,…\n#> $ Poverty          <dbl> 1.36, 1.36, 1.36, 1.07, 1.91, 1.84, 2.33,…\n#> $ HomeRooms        <int> 6, 6, 6, 9, 5, 6, 7, 6, 6, 6, 5, 10, 6, 1…\n#> $ HomeOwn          <fct> Own, Own, Own, Own, Rent, Rent, Own, Own,…\n#> $ Work             <fct> NotWorking, NotWorking, NotWorking, NA, N…\n#> $ Weight           <dbl> 87.4, 87.4, 87.4, 17.0, 86.7, 29.8, 35.2,…\n#> $ Length           <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ HeadCirc         <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ Height           <dbl> 165, 165, 165, 105, 168, 133, 131, 167, 1…\n#> $ BMI              <dbl> 32.2, 32.2, 32.2, 15.3, 30.6, 16.8, 20.6,…\n#> $ BMICatUnder20yrs <fct> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ BMI_WHO          <fct> 30.0_plus, 30.0_plus, 30.0_plus, 12.0_18.…\n#> $ Pulse            <int> 70, 70, 70, NA, 86, 82, 72, 62, 62, 62, 6…\n#> $ BPSysAve         <int> 113, 113, 113, NA, 112, 86, 107, 118, 118…\n#> $ BPDiaAve         <int> 85, 85, 85, NA, 75, 47, 37, 64, 64, 64, 6…\n#> $ BPSys1           <int> 114, 114, 114, NA, 118, 84, 114, 106, 106…\n#> $ BPDia1           <int> 88, 88, 88, NA, 82, 50, 46, 62, 62, 62, 6…\n#> $ BPSys2           <int> 114, 114, 114, NA, 108, 84, 108, 118, 118…\n#> $ BPDia2           <int> 88, 88, 88, NA, 74, 50, 36, 68, 68, 68, 6…\n#> $ BPSys3           <int> 112, 112, 112, NA, 116, 88, 106, 118, 118…\n#> $ BPDia3           <int> 82, 82, 82, NA, 76, 44, 38, 60, 60, 60, 6…\n#> $ Testosterone     <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ DirectChol       <dbl> 1.29, 1.29, 1.29, NA, 1.16, 1.34, 1.55, 2…\n#> $ TotChol          <dbl> 3.49, 3.49, 3.49, NA, 6.70, 4.86, 4.09, 5…\n#> $ UrineVol1        <int> 352, 352, 352, NA, 77, 123, 238, 106, 106…\n#> $ UrineFlow1       <dbl> NA, NA, NA, NA, 0.094, 1.538, 1.322, 1.11…\n#> $ UrineVol2        <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ UrineFlow2       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ Diabetes         <fct> No, No, No, No, No, No, No, No, No, No, N…\n#> $ DiabetesAge      <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ HealthGen        <fct> Good, Good, Good, NA, Good, NA, NA, Vgood…\n#> $ DaysPhysHlthBad  <int> 0, 0, 0, NA, 0, NA, NA, 0, 0, 0, 10, 0, 4…\n#> $ DaysMentHlthBad  <int> 15, 15, 15, NA, 10, NA, NA, 3, 3, 3, 0, 0…\n#> $ LittleInterest   <fct> Most, Most, Most, NA, Several, NA, NA, No…\n#> $ Depressed        <fct> Several, Several, Several, NA, Several, N…\n#> $ nPregnancies     <int> NA, NA, NA, NA, 2, NA, NA, 1, 1, 1, NA, N…\n#> $ nBabies          <int> NA, NA, NA, NA, 2, NA, NA, NA, NA, NA, NA…\n#> $ Age1stBaby       <int> NA, NA, NA, NA, 27, NA, NA, NA, NA, NA, N…\n#> $ SleepHrsNight    <int> 4, 4, 4, NA, 8, NA, NA, 8, 8, 8, 7, 5, 4,…\n#> $ SleepTrouble     <fct> Yes, Yes, Yes, NA, Yes, NA, NA, No, No, N…\n#> $ PhysActive       <fct> No, No, No, NA, No, NA, NA, Yes, Yes, Yes…\n#> $ PhysActiveDays   <int> NA, NA, NA, NA, NA, NA, NA, 5, 5, 5, 7, 5…\n#> $ TVHrsDay         <fct> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ CompHrsDay       <fct> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ TVHrsDayChild    <int> NA, NA, NA, 4, NA, 5, 1, NA, NA, NA, NA, …\n#> $ CompHrsDayChild  <int> NA, NA, NA, 1, NA, 0, 6, NA, NA, NA, NA, …\n#> $ Alcohol12PlusYr  <fct> Yes, Yes, Yes, NA, Yes, NA, NA, Yes, Yes,…\n#> $ AlcoholDay       <int> NA, NA, NA, NA, 2, NA, NA, 3, 3, 3, 1, 2,…\n#> $ AlcoholYear      <int> 0, 0, 0, NA, 20, NA, NA, 52, 52, 52, 100,…\n#> $ SmokeNow         <fct> No, No, No, NA, Yes, NA, NA, NA, NA, NA, …\n#> $ Smoke100         <fct> Yes, Yes, Yes, NA, Yes, NA, NA, No, No, N…\n#> $ Smoke100n        <fct> Smoker, Smoker, Smoker, NA, Smoker, NA, N…\n#> $ SmokeAge         <int> 18, 18, 18, NA, 38, NA, NA, NA, NA, NA, 1…\n#> $ Marijuana        <fct> Yes, Yes, Yes, NA, Yes, NA, NA, Yes, Yes,…\n#> $ AgeFirstMarij    <int> 17, 17, 17, NA, 18, NA, NA, 13, 13, 13, N…\n#> $ RegularMarij     <fct> No, No, No, NA, No, NA, NA, No, No, No, N…\n#> $ AgeRegMarij      <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ HardDrugs        <fct> Yes, Yes, Yes, NA, Yes, NA, NA, No, No, N…\n#> $ SexEver          <fct> Yes, Yes, Yes, NA, Yes, NA, NA, Yes, Yes,…\n#> $ SexAge           <int> 16, 16, 16, NA, 12, NA, NA, 13, 13, 13, 1…\n#> $ SexNumPartnLife  <int> 8, 8, 8, NA, 10, NA, NA, 20, 20, 20, 15, …\n#> $ SexNumPartYear   <int> 1, 1, 1, NA, 1, NA, NA, 0, 0, 0, NA, 1, 1…\n#> $ SameSex          <fct> No, No, No, NA, Yes, NA, NA, Yes, Yes, Ye…\n#> $ SexOrientation   <fct> Heterosexual, Heterosexual, Heterosexual,…\n#> $ PregnantNow      <fct> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n:::\n:::\n\n\nThis gives us a quick overview of what variables are in the dataset and\nthe data types that they are.\n\n## Selecting specific columns in a dataset\n\nSelecting columns of a dataset is a very common data wrangling task. The\nfunction for this task in RStudio is appropriately called `select()`.\nYou would use `select()` to extract one or more variables in a dataset\nthat you want to have a closer look at or to save as a new data frame to\nwork with. It may be that you wish to explore the clinical\ncharacteristics of your study sample, so you may select some basic\ndemographic variables (e.g., the `Age` column) and clinical variables\n(e.g., `Weight` and `Height` columns) to perform these analyses.\n\nFor the input arguments, `select()` takes the dataset as the first\nargument, which is the first input position right after the opening\nbracket `(`, and then takes the names of the columns you want to select.\nThe argument after the data argument is `...`, which indicates that you\ncan add as many columns as you want, separated by a `,`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select one column by its name, without quotes\nselect(NHANES, Age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 1\n#>      Age\n#>    <int>\n#>  1    34\n#>  2    34\n#>  3    34\n#>  4     4\n#>  5    49\n#>  6     9\n#>  7     8\n#>  8    45\n#>  9    45\n#> 10    45\n#> # … with 9,990 more rows\n```\n:::\n\n```{.r .cell-code}\n# Select two or more columns by name, without quotes\nselect(NHANES, Age, Weight, BMI)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 3\n#>      Age Weight   BMI\n#>    <int>  <dbl> <dbl>\n#>  1    34   87.4  32.2\n#>  2    34   87.4  32.2\n#>  3    34   87.4  32.2\n#>  4     4   17    15.3\n#>  5    49   86.7  30.6\n#>  6     9   29.8  16.8\n#>  7     8   35.2  20.6\n#>  8    45   75.7  27.2\n#>  9    45   75.7  27.2\n#> 10    45   75.7  27.2\n#> # … with 9,990 more rows\n```\n:::\n\n```{.r .cell-code}\n# To *exclude* a column, use minus (-)\nselect(NHANES, -HeadCirc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 75\n#>       ID SurveyYr Gender   Age AgeDecade AgeMo…¹ Race1 Race3 Educa…²\n#>    <int> <fct>    <fct>  <int> <fct>       <int> <fct> <fct> <fct>  \n#>  1 51624 2009_10  male      34 \" 30-39\"      409 White <NA>  High S…\n#>  2 51624 2009_10  male      34 \" 30-39\"      409 White <NA>  High S…\n#>  3 51624 2009_10  male      34 \" 30-39\"      409 White <NA>  High S…\n#>  4 51625 2009_10  male       4 \" 0-9\"         49 Other <NA>  <NA>   \n#>  5 51630 2009_10  female    49 \" 40-49\"      596 White <NA>  Some C…\n#>  6 51638 2009_10  male       9 \" 0-9\"        115 White <NA>  <NA>   \n#>  7 51646 2009_10  male       8 \" 0-9\"        101 White <NA>  <NA>   \n#>  8 51647 2009_10  female    45 \" 40-49\"      541 White <NA>  Colleg…\n#>  9 51647 2009_10  female    45 \" 40-49\"      541 White <NA>  Colleg…\n#> 10 51647 2009_10  female    45 \" 40-49\"      541 White <NA>  Colleg…\n#> # … with 9,990 more rows, 66 more variables: MaritalStatus <fct>,\n#> #   HHIncome <fct>, HHIncomeMid <int>, Poverty <dbl>,\n#> #   HomeRooms <int>, HomeOwn <fct>, Work <fct>, Weight <dbl>,\n#> #   Length <dbl>, Height <dbl>, BMI <dbl>, BMICatUnder20yrs <fct>,\n#> #   BMI_WHO <fct>, Pulse <int>, BPSysAve <int>, BPDiaAve <int>,\n#> #   BPSys1 <int>, BPDia1 <int>, BPSys2 <int>, BPDia2 <int>,\n#> #   BPSys3 <int>, BPDia3 <int>, Testosterone <dbl>, …\n```\n:::\n:::\n\n\nIf some of your columns have similar patterns for naming at the\nbeginning, middle, or end of the name, you can use some helper functions\nto choose these columns. Use `?select_helpers` (choose the \"Select\nhelpers\" option in the menu that pops up) to read more about these\nfunctions and to get help on them. Some commonly used helpers are:\n\n-   `starts_with()`: Select columns that begin with a pattern.\n-   `ends_with()`: Select columns that end with a pattern.\n-   `contains()`: Select columns that contain a pattern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# All columns starting with letters \"BP\" (blood pressure)\nselect(NHANES, starts_with(\"BP\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>    BPSysAve BPDiaAve BPSys1 BPDia1 BPSys2 BPDia2 BPSys3 BPDia3\n#>       <int>    <int>  <int>  <int>  <int>  <int>  <int>  <int>\n#>  1      113       85    114     88    114     88    112     82\n#>  2      113       85    114     88    114     88    112     82\n#>  3      113       85    114     88    114     88    112     82\n#>  4       NA       NA     NA     NA     NA     NA     NA     NA\n#>  5      112       75    118     82    108     74    116     76\n#>  6       86       47     84     50     84     50     88     44\n#>  7      107       37    114     46    108     36    106     38\n#>  8      118       64    106     62    118     68    118     60\n#>  9      118       64    106     62    118     68    118     60\n#> 10      118       64    106     62    118     68    118     60\n#> # … with 9,990 more rows\n```\n:::\n\n```{.r .cell-code}\n# All columns ending in letters \"Day\"\nselect(NHANES, ends_with(\"Day\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 3\n#>    TVHrsDay CompHrsDay AlcoholDay\n#>    <fct>    <fct>           <int>\n#>  1 <NA>     <NA>               NA\n#>  2 <NA>     <NA>               NA\n#>  3 <NA>     <NA>               NA\n#>  4 <NA>     <NA>               NA\n#>  5 <NA>     <NA>                2\n#>  6 <NA>     <NA>               NA\n#>  7 <NA>     <NA>               NA\n#>  8 <NA>     <NA>                3\n#>  9 <NA>     <NA>                3\n#> 10 <NA>     <NA>                3\n#> # … with 9,990 more rows\n```\n:::\n\n```{.r .cell-code}\n# All columns containing letters \"Age\"\nselect(NHANES, contains(\"Age\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 9\n#>      Age AgeDecade AgeMonths Diabe…¹ Age1s…² Smoke…³ AgeFi…⁴ AgeRe…⁵\n#>    <int> <fct>         <int>   <int>   <int>   <int>   <int>   <int>\n#>  1    34 \" 30-39\"        409      NA      NA      18      17      NA\n#>  2    34 \" 30-39\"        409      NA      NA      18      17      NA\n#>  3    34 \" 30-39\"        409      NA      NA      18      17      NA\n#>  4     4 \" 0-9\"           49      NA      NA      NA      NA      NA\n#>  5    49 \" 40-49\"        596      NA      27      38      18      NA\n#>  6     9 \" 0-9\"          115      NA      NA      NA      NA      NA\n#>  7     8 \" 0-9\"          101      NA      NA      NA      NA      NA\n#>  8    45 \" 40-49\"        541      NA      NA      NA      13      NA\n#>  9    45 \" 40-49\"        541      NA      NA      NA      13      NA\n#> 10    45 \" 40-49\"        541      NA      NA      NA      13      NA\n#> # … with 9,990 more rows, 1 more variable: SexAge <int>, and\n#> #   abbreviated variable names ¹​DiabetesAge, ²​Age1stBaby,\n#> #   ³​SmokeAge, ⁴​AgeFirstMarij, ⁵​AgeRegMarij\n```\n:::\n:::\n\n\nFor more information on using the pattern functions such as\n`starts_with()`, check out `?select_helpers`.\n\nYou'll notice that running these functions doesn't actually change the\ndata itself. When you run a function without assigning it using `<-`,\nthe only action the function does is to send the output to your screen,\nand you won't have saved that data anywhere for later use. But if you\nwant to create a new dataset with only the columns you selected, you'll\nneed to assign the selected dataset to a new object.\n\nThe full NHANES dataset is 10,000 individuals (rows) with 76 parameters\n(columns). To make it easier to look at and since we are only interested\nin some of these parameters, we will subset the large dataset into\nsomething smaller and save it for later use as a new dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save the selected columns as a new data frame\n# Recall the style guide for naming objects\nnhanes_small <- select(NHANES, Age, Gender, BMI, Diabetes,\n                       PhysActive, BPSysAve, BPDiaAve, Education)\n\n# View the new data frame\nnhanes_small\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      Age Gender   BMI Diabetes PhysActive BPSysAve BPDiaAve Educat…¹\n#>    <int> <fct>  <dbl> <fct>    <fct>         <int>    <int> <fct>   \n#>  1    34 male    32.2 No       No              113       85 High Sc…\n#>  2    34 male    32.2 No       No              113       85 High Sc…\n#>  3    34 male    32.2 No       No              113       85 High Sc…\n#>  4     4 male    15.3 No       <NA>             NA       NA <NA>    \n#>  5    49 female  30.6 No       No              112       75 Some Co…\n#>  6     9 male    16.8 No       <NA>             86       47 <NA>    \n#>  7     8 male    20.6 No       <NA>            107       37 <NA>    \n#>  8    45 female  27.2 No       Yes             118       64 College…\n#>  9    45 female  27.2 No       Yes             118       64 College…\n#> 10    45 female  27.2 No       Yes             118       64 College…\n#> # … with 9,990 more rows, and abbreviated variable name ¹​Education\n```\n:::\n:::\n\n\n## Renaming all column names based on the style guide\n\nIn the interests of keeping data tidy and matching the [style\nguide](https://style.tidyverse.org/), we should change the column names\nto be all lower case with `_` for spaces between words. There's a\npackage that can do that for us called `{snakecase}`.\n\nTo change all the column names to snakecase, we'll use the function\n`rename_with()`. This function takes the data as the first argument but\nthe second argument needs to be a function, which in our case is called\n`snakecase::to_snake_case()`, but exclude the `()` at the end. This\nfunction will rename all columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rename all columns to snake case\nnhanes_small <- rename_with(nhanes_small, snakecase::to_snake_case)\n\n# Have a look at the data frame\nnhanes_small\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age gender   bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    34 male    32.2 No       No                113      85 High S…\n#>  2    34 male    32.2 No       No                113      85 High S…\n#>  3    34 male    32.2 No       No                113      85 High S…\n#>  4     4 male    15.3 No       <NA>               NA      NA <NA>   \n#>  5    49 female  30.6 No       No                112      75 Some C…\n#>  6     9 male    16.8 No       <NA>               86      47 <NA>   \n#>  7     8 male    20.6 No       <NA>              107      37 <NA>   \n#>  8    45 female  27.2 No       Yes               118      64 Colleg…\n#>  9    45 female  27.2 No       Yes               118      64 Colleg…\n#> 10    45 female  27.2 No       Yes               118      64 Colleg…\n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\n## Renaming specific columns\n\nDepending on how your data was collected, it may have column names that\naren't very descriptive. So you'll probably want to rename them to\nsomething more explanatory, which is particularly important if you're\nsharing your work with others or in an environment where multiple people\nare working on the same data. We will use the function called\n`rename()`. Like `select()`, `rename()` takes the dataset as the first\nargument and then takes as many renaming arguments as you want (because\nthe second argument position is `...`). When renaming, it takes the form\nof `newname = oldname`.\n\nThe \"gender\" variable in the dataset actually describes \"sex\", so let's\nrename it to accurately reflect the data itself. Note that gender is a\n*social construct*, while sex is *biological*. This unfortunately is\noften incorrectly named in many scientific papers, where accuracy of\nterms is critical. Because we want to rename the variable in the dataset\nso it stays renamed, we need to assign it again to `nhanes_small`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small <- rename(nhanes_small, sex = gender)\nnhanes_small\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    34 male    32.2 No       No                113      85 High S…\n#>  2    34 male    32.2 No       No                113      85 High S…\n#>  3    34 male    32.2 No       No                113      85 High S…\n#>  4     4 male    15.3 No       <NA>               NA      NA <NA>   \n#>  5    49 female  30.6 No       No                112      75 Some C…\n#>  6     9 male    16.8 No       <NA>               86      47 <NA>   \n#>  7     8 male    20.6 No       <NA>              107      37 <NA>   \n#>  8    45 female  27.2 No       Yes               118      64 Colleg…\n#>  9    45 female  27.2 No       Yes               118      64 Colleg…\n#> 10    45 female  27.2 No       Yes               118      64 Colleg…\n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\n::: callout-tip\nWe've re-assigned the object `nhanes_small` multiple times. If you make\na mistake, the easiest solution is to re-run the code from the start\nagain, which should fix any issues.\n:::\n\nNow, you can see that the column has been renamed from `gender` to\n`sex`. What if you wanted to select some columns and then rename some of\nthem? Would you have to create a new data object every time? No! We can\nmake use of a very powerful tool called piping with the `%>%` function.\n\n## Chaining functions with the pipe\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nA key component of tidy data and tidy code is making use of the \"pipe\"\noperator, `%>%`. There is also the base R pipe `|>`, which works\nbasically the same but with some small differences. For this course we\nwill use `%>%`, though you can use either.\n\nYou would use the \"pipe\" operator when you are writing a piece of code\nwith multiple operations or intermediate steps that require you to save\nand overwrite each step as an object (see below). One advantage of the\n\"pipe\" operator is that it will help to ensure that your code is less\ncluttered with redundant and temporary object names.\n\nThis operator allows you to \"pipe\" the output from one function to the\ninput of another function, just like a plumbing pipe would do for water.\nThis allows you to easily chain functions together into \"sentences\".\nLet's use an example based on English words for some action. This is the\nEnglish sentence:\n\n> We need some eggs. Drive to the grocery store and buy some eggs before\n> arriving home from work.\n\nThere are basically two actions here (\"drive\" and \"buy\") with four\ninputs (\"work\", \"grocery store\", \"eggs\", \"home\"), that are all based on\nthe previous action. Since an action in R is a function, the functions\nwould be `drive()` and `buy()`. In regular R (without the \"pipe\"\noperator), we would have to nest functions (reading from the inside to\nthe outside) together to chain them:\n\n``` r\ndrive(buy(drive(at_work, \"grocery store\"), \"eggs\"), \"home\")\n```\n\nThis is difficult to read. Another way to chain functions would be to\ncreate temporary objects for each step:\n\n``` r\nat_grocery_store <- drive(at_work, \"grocery store\")\ngot_eggs <- buy(at_grocery_store, \"eggs\")\nat_home <- drive(got_eggs, \"home\")\n```\n\nThis still isn't very \"readable\", as we are having to re-name each\nintermediate object with reference to the object before it. The pipe\n`%>%` operator can really simplify this:\n\n``` r\nat_work %>% \n    drive(\"grocery store\") %>% \n    buy(\"eggs\") %>% \n    drive(\"home\")\n```\n\nDo you find this more readable and understandable? It reads how it would\nbe done, in order of the steps taken.\n\nThe idea of piping is to read the functions from left to right. This can\nhelp clarify and break down complex data processing workflows, and is\nthe basis for the tidyverse and many other packages.\n\nThe operator `%>%` takes the output from the object or function from the\nleft of the operator and puts it into the function on the right of the\noperator. All input goes into the first position argument of the\nfunction. Within the tidyverse packages, all functions take a data frame\n(or vector) as the first argument in order to work with the pipe.\n:::\n\nLet's try this out on NHANES. The keyboard shortcut for the pipe is\n`Ctrl-Shift-M` (i.e., M for the `{magrittr}` package that created the\npipe).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These two ways are the same\ncolnames(nhanes_small)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] \"age\"         \"sex\"         \"bmi\"         \"diabetes\"   \n#> [5] \"phys_active\" \"bp_sys_ave\"  \"bp_dia_ave\"  \"education\"\n```\n:::\n\n```{.r .cell-code}\nnhanes_small %>% \n    colnames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] \"age\"         \"sex\"         \"bmi\"         \"diabetes\"   \n#> [5] \"phys_active\" \"bp_sys_ave\"  \"bp_dia_ave\"  \"education\"\n```\n:::\n:::\n\n\nThe pipe automatically takes `nhanes_small` and puts it into the first\nposition, so we don't need to specify `nhanes_small` inside `colnames()`\nwhen piping.\n\nLet's try using the pipe with the `select()` and `rename()` functions\nfrom the previous section. Remember, both `select()` and `rename()` take\na dataset as the first argument, which makes them pipe-able.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>% \n    select(phys_active) %>% \n    rename(physically_active = phys_active)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 1\n#>    physically_active\n#>    <fct>            \n#>  1 No               \n#>  2 No               \n#>  3 No               \n#>  4 <NA>             \n#>  5 No               \n#>  6 <NA>             \n#>  7 <NA>             \n#>  8 Yes              \n#>  9 Yes              \n#> 10 Yes              \n#> # … with 9,990 more rows\n```\n:::\n:::\n\n\nWe can now \"read\" these actions as:\n\n> Take the nhanes_small dataset *and then* select the \"phys_active\"\n> column *and then* rename the \"phys_active\" column to\n> \"physically_active\".\n\n## Exercise: Practice what we've learned\n\n> Time: 10 minutes.\n\nIn the `R/learning.R` script file, complete the following tasks.\n\n1.  Copy and paste the code below into the script file. Replace the\n    `___` in the `select()` function, with the columns `bp_sys_ave`, and\n    `education`.\n\n    ``` r\n    nhanes_small %>% \n        select(___)\n    ```\n\n2.  Copy and paste the code below and fill out the blanks. Rename the\n    `bp_` variables so they don't end in `_ave`, so they look like\n    `bp_sys` and `bp_dia`. *Tip*: Recall that renaming is in the form\n    `new = old`.\n\n    ``` r\n    nhanes_small %>% \n        rename(___ = ___,\n               ___ = ___)\n    ```\n\n3.  Re-write this piece of code using the \"pipe\" operator:\n\n    ``` r\n    select(nhanes_small, bmi, contains(\"age\"))\n    ```\n\n4.  Read through (in your head) the code below. How intuitive is it to\n    read? Now, re-write this code so that you don't need to create the\n    temporary `blood_pressure` object by using the pipe, then re-read\n    the revised version. Which do you feel is easier to \"read\"?\n\n    ``` r\n    blood_pressure <- select(nhanes_small, starts_with(\"bp_\"))\n    rename(blood_pressure, bp_systolic = bp_sys_ave)\n    ```\n\n5.  Run `{styler}` on the `R/learning.R` file with\n    `Ctrl-Shift-P`, then type \"style file\".\n\n6.  Lastly, add and commit these changes to the Git history with the\n    RStudio Git interface (`Ctrl-Shift-P`, then type \"commit\").\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n# 1. Select specific columns\nnhanes_small %>%\n    select(bp_sys_ave, education)\n\n# 2. Rename columns\nnhanes_small %>%\n    rename(bp_sys = bp_sys_ave,\n           bp_dia = bp_dia_ave)\n\n# 3. Re-write with pipe\nnhanes_small %>% \n    select(bmi, contains(\"age\"))\n\n# 4. Re-write with pipe\nnhanes_small %>% \n    select(starts_with(\"bp_\")) %>% \n    rename(bp_systolic = bp_sys_ave)\n```\n:::\n\n\n## Filtering data by row\n\nFiltering data by row is a very common activity in data analysis,\nespecially if you want to get rid of outliers or to subset by a\ncategorical group. The function to subset or filter is called\n`filter()`. `filter()` is distinct from `select()` in the sense that it\noperates on rows, whereas `select()` operates on columns.\n\nThe `filter()` function takes a logic condition (`TRUE` or `FALSE`). As\nwith the other functions, the first argument is the dataset and all\nothers are the logical conditions that will apply to the row filtering.\nWhen the logical conditions equal `TRUE`, it means that those rows will\nbe **kept** and those that are `FALSE` will be *dropped*.\n\n*Warning*: Since `filter()` uses logical conditions, you need to be\nreally careful when writing the logic. As you probably know, humans are\nreally *really* bad at logic. If your logical condition starts getting\ncomplex, double and triple check that you know for certain that your\nlogic code is doing what you think it is doing. It's very easy to make\nmistakes at this stage, even for advanced R users.\n\nThe simplest kind of logic condition is to test for \"equality\". In R,\n\"equal to\" is represented by `==`. For example, if we wanted to keep\nonly people who are not physically active in the dataset, we would use\nthe logic condition like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    filter(phys_active == \"No\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 3,677 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    34 male    32.2 No       No                113      85 High S…\n#>  2    34 male    32.2 No       No                113      85 High S…\n#>  3    34 male    32.2 No       No                113      85 High S…\n#>  4    49 female  30.6 No       No                112      75 Some C…\n#>  5    33 male    28.5 No       No                128      74 High S…\n#>  6    60 male    25.8 No       No                152     100 High S…\n#>  7    38 male    35.8 No       No                147      81 Some C…\n#>  8    44 male    31.4 Yes      No                144      88 9 - 11…\n#>  9    44 male    31.4 Yes      No                144      88 9 - 11…\n#> 10    59 female  25.8 Yes      No                150       0 8th Gr…\n#> # … with 3,667 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\nWe would \"read\" this code as:\n\n> Take the nhanes_small dataset *and then* filter so that only rows\n> where `phys_active` is equal to \"No\" are kept.\n\nWhen a row in the `phys_active` column has the value `\"No\"`, that row is\nkept. Otherwise, it is dropped.\n\nThere are other logic comparisons to use. @tbl-logic-operators can be\nused as a reference for logical conditions in R.\n\n\n::: {#tbl-logic-operators .cell tbl-cap='Logical operators in R.'}\n::: {.cell-output-display}\n|Operator   |Description                   |\n|:----------|:-----------------------------|\n|<          |less than                     |\n|<=         |less than or equal to         |\n|>          |greater than                  |\n|>=         |greater than or equal to      |\n|==         |equal to                      |\n|!=         |not equal to                  |\n|!x         |Not x (if x is true or false) |\n|x &#124; y |x OR y                        |\n|x & y      |x AND y                       |\n:::\n:::\n\n\nLet's try out a few of these logical conditions with `filter()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Participants who are physically active\nnhanes_small %>%\n    filter(phys_active != \"No\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 4,649 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    45 female  27.2 No       Yes               118      64 Colleg…\n#>  2    45 female  27.2 No       Yes               118      64 Colleg…\n#>  3    45 female  27.2 No       Yes               118      64 Colleg…\n#>  4    66 male    23.7 No       Yes               111      63 Some C…\n#>  5    58 male    23.7 No       Yes               104      74 Colleg…\n#>  6    54 male    26.0 No       Yes               134      85 9 - 11…\n#>  7    58 female  26.2 No       Yes               127      83 High S…\n#>  8    50 male    26.6 No       Yes               142      68 Some C…\n#>  9    16 male    24.7 No       Yes               126      72 <NA>   \n#> 10    56 female  19.7 No       Yes                95      69 Colleg…\n#> # … with 4,639 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n\n```{.r .cell-code}\n# Participants who have BMI equal to 25\nnhanes_small %>%\n    filter(bmi == 25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 35 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    24 male      25 No       Yes               109      61 8th Gr…\n#>  2    24 male      25 No       Yes               109      61 8th Gr…\n#>  3    32 male      25 No       No                104      73 Colleg…\n#>  4    32 male      25 No       No                104      73 Colleg…\n#>  5    32 male      25 No       No                104      73 Colleg…\n#>  6    32 male      25 No       No                104      73 Colleg…\n#>  7    55 female    25 No       Yes               106      63 Some C…\n#>  8     6 female    25 No       <NA>               NA      NA <NA>   \n#>  9    53 male      25 No       No                113      84 9 - 11…\n#> 10    57 female    25 No       Yes               131      75 Colleg…\n#> # … with 25 more rows, and abbreviated variable names ¹​bp_sys_ave,\n#> #   ²​bp_dia_ave, ³​education\n```\n:::\n\n```{.r .cell-code}\n# Participants who have BMI equal to or more than 25\nnhanes_small %>%\n    filter(bmi >= 25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 5,422 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    34 male    32.2 No       No                113      85 High S…\n#>  2    34 male    32.2 No       No                113      85 High S…\n#>  3    34 male    32.2 No       No                113      85 High S…\n#>  4    49 female  30.6 No       No                112      75 Some C…\n#>  5    45 female  27.2 No       Yes               118      64 Colleg…\n#>  6    45 female  27.2 No       Yes               118      64 Colleg…\n#>  7    45 female  27.2 No       Yes               118      64 Colleg…\n#>  8    54 male    26.0 No       Yes               134      85 9 - 11…\n#>  9    58 female  26.2 No       Yes               127      83 High S…\n#> 10    50 male    26.6 No       Yes               142      68 Some C…\n#> # … with 5,412 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\nWe use the `|` (\"or\") and `&` (\"and\") when we want to combine conditions\nacross columns. Be careful with these operators and when combining logic\nconditions, as they can sometimes work differently than our human brains\ninterpret them (speaking from experience). For `&`, both sides must be\n`TRUE` in order for the combination to be `TRUE`. For `|`, only one side\nneeds to be `TRUE` in order for the combination to be `TRUE`. To see how\nthey work try these:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nFALSE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n:::\n\n\nWhen used in `filter()`, combinations of logic conditions may look like\nthis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# When BMI is 25 AND phys_active is No\nnhanes_small %>%\n    filter(bmi == 25 & phys_active == \"No\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 11 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    32 male      25 No       No                104      73 Colleg…\n#>  2    32 male      25 No       No                104      73 Colleg…\n#>  3    32 male      25 No       No                104      73 Colleg…\n#>  4    32 male      25 No       No                104      73 Colleg…\n#>  5    53 male      25 No       No                113      84 9 - 11…\n#>  6    20 female    25 No       No                111      76 High S…\n#>  7    23 female    25 No       No                125      70 Colleg…\n#>  8    51 female    25 No       No                144      94 High S…\n#>  9    51 female    25 No       No                144      94 High S…\n#> 10    51 female    25 No       No                144      94 High S…\n#> 11    51 female    25 No       No                144      94 High S…\n#> # … with abbreviated variable names ¹​bp_sys_ave, ²​bp_dia_ave,\n#> #   ³​education\n```\n:::\n\n```{.r .cell-code}\n# When BMI is 25 OR phys_active is No\nnhanes_small %>%\n    filter(bmi == 25 | phys_active == \"No\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 3,701 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    34 male    32.2 No       No                113      85 High S…\n#>  2    34 male    32.2 No       No                113      85 High S…\n#>  3    34 male    32.2 No       No                113      85 High S…\n#>  4    49 female  30.6 No       No                112      75 Some C…\n#>  5    33 male    28.5 No       No                128      74 High S…\n#>  6    60 male    25.8 No       No                152     100 High S…\n#>  7    38 male    35.8 No       No                147      81 Some C…\n#>  8    44 male    31.4 Yes      No                144      88 9 - 11…\n#>  9    44 male    31.4 Yes      No                144      88 9 - 11…\n#> 10    59 female  25.8 Yes      No                150       0 8th Gr…\n#> # … with 3,691 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\n## Arranging the rows of your data by column\n\nYou may want to sort your rows by a specific column so that values are\narranged in ascending or descending order. This can be done using the\nfunction called `arrange()`. Again, `arrange()` takes the dataset as the\nfirst argument, followed by the columns that you wish to arrange data\nby. By default, `arrange()` orders in *ascending* order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arranging data by age in ascending order\nnhanes_small %>%\n    arrange(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#>  2     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#>  3     0 male      NA <NA>     <NA>               NA      NA <NA>   \n#>  4     0 male      NA <NA>     <NA>               NA      NA <NA>   \n#>  5     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#>  6     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#>  7     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#>  8     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#>  9     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#> 10     0 female    NA <NA>     <NA>               NA      NA <NA>   \n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\n`arrange()` also arranges parameters of type `character` alphabetically:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>% \n    arrange(education)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    64 female  27.2 Yes      Yes               130      65 8th Gr…\n#>  2    59 female  25.8 Yes      No                150       0 8th Gr…\n#>  3    59 female  25.8 Yes      No                150       0 8th Gr…\n#>  4    56 male    25.0 Yes      No                 86      54 8th Gr…\n#>  5    78 female  22.6 Yes      No                133      61 8th Gr…\n#>  6    31 female  29.0 No       No                119      65 8th Gr…\n#>  7    31 female  29.0 No       No                119      65 8th Gr…\n#>  8    26 female  25.9 No       Yes                99      70 8th Gr…\n#>  9    26 female  25.9 No       Yes                99      70 8th Gr…\n#> 10    26 female  25.9 No       Yes                99      70 8th Gr…\n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\nIf we want to order the column based on descending order, this can be\ndone with `desc()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arranging data by age in descending order\nnhanes_small %>%\n    arrange(desc(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    80 female  27.2 No       No                172      86 9 - 11…\n#>  2    80 female  27.2 No       No                172      86 9 - 11…\n#>  3    80 male    17.9 No       No                132      60 High S…\n#>  4    80 male    34.0 Yes      No                125      56 9 - 11…\n#>  5    80 male    29.3 Yes      Yes               149      75 High S…\n#>  6    80 female  33.1 No       No                117      55 9 - 11…\n#>  7    80 female  24.8 No       No                138      35 8th Gr…\n#>  8    80 female  24.8 No       No                138      35 8th Gr…\n#>  9    80 male    26.5 No       No                113      65 High S…\n#> 10    80 female  25.8 No       No                137      73 High S…\n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\nYou can also order your data by multiple columns. For instance, we could\narrange first by `education` and then by `age`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arranging data by education then age in ascending order\nnhanes_small %>%\n    arrange(education, age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <int> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1    20 male    25.4 No       Yes               115      67 8th Gr…\n#>  2    21 male    25.6 No       No                110      52 8th Gr…\n#>  3    21 male    22.3 No       No                107      67 8th Gr…\n#>  4    22 male    28.0 No       No                135      70 8th Gr…\n#>  5    22 female  42.5 No       No                 94      72 8th Gr…\n#>  6    22 female  42.5 No       No                 94      72 8th Gr…\n#>  7    22 male    25.2 No       No                123      63 8th Gr…\n#>  8    22 male    27.3 No       No                115      78 8th Gr…\n#>  9    22 female  61.0 No       No                103      64 8th Gr…\n#> 10    23 female  32.3 No       No                118      55 8th Gr…\n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\n## Transform or add columns\n\nTo modify an existing column or to add a new one, we can use the\nfunction called `mutate()`. You can use `mutate()` to compute a new\nvariable using existing columns in your dataset. You can multiply all\nvalues in a certain column by 2, or combine columns into a new variable.\nLike the other functions, the first input is the dataset and the other\narguments are columns to add or modify.\n\nTake this example: In some analyses, sometimes age is reflected as\nmonths, not years. Since NHANES has age in years, to convert to months\nwe would multiply by 12. So, we would use `mutate()` with the following\ninstruction:\n\n    age = age * 12\n\nThis form is similar to how math works. The action that happens on the\nright hand side is put into the variable of the left hand side. When\nusing `mutate()`, it looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    mutate(age = age * 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 8\n#>      age sex      bmi diabetes phys_active bp_sys_…¹ bp_di…² educa…³\n#>    <dbl> <fct>  <dbl> <fct>    <fct>           <int>   <int> <fct>  \n#>  1   408 male    32.2 No       No                113      85 High S…\n#>  2   408 male    32.2 No       No                113      85 High S…\n#>  3   408 male    32.2 No       No                113      85 High S…\n#>  4    48 male    15.3 No       <NA>               NA      NA <NA>   \n#>  5   588 female  30.6 No       No                112      75 Some C…\n#>  6   108 male    16.8 No       <NA>               86      47 <NA>   \n#>  7    96 male    20.6 No       <NA>              107      37 <NA>   \n#>  8   540 female  27.2 No       Yes               118      64 Colleg…\n#>  9   540 female  27.2 No       Yes               118      64 Colleg…\n#> 10   540 female  27.2 No       Yes               118      64 Colleg…\n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​bp_sys_ave, ²​bp_dia_ave, ³​education\n```\n:::\n:::\n\n\nLike with `filter()`, you can continue to add or modify more columns by\nusing `,`. So let's do that to a new column (e.g., log transforming\nBMI):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    mutate(age = age * 12,\n           logged_bmi = log(bmi))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 9\n#>      age sex     bmi diabe…¹ phys_…² bp_sy…³ bp_di…⁴ educa…⁵ logge…⁶\n#>    <dbl> <fct> <dbl> <fct>   <fct>     <int>   <int> <fct>     <dbl>\n#>  1   408 male   32.2 No      No          113      85 High S…    3.47\n#>  2   408 male   32.2 No      No          113      85 High S…    3.47\n#>  3   408 male   32.2 No      No          113      85 High S…    3.47\n#>  4    48 male   15.3 No      <NA>         NA      NA <NA>       2.73\n#>  5   588 fema…  30.6 No      No          112      75 Some C…    3.42\n#>  6   108 male   16.8 No      <NA>         86      47 <NA>       2.82\n#>  7    96 male   20.6 No      <NA>        107      37 <NA>       3.03\n#>  8   540 fema…  27.2 No      Yes         118      64 Colleg…    3.30\n#>  9   540 fema…  27.2 No      Yes         118      64 Colleg…    3.30\n#> 10   540 fema…  27.2 No      Yes         118      64 Colleg…    3.30\n#> # … with 9,990 more rows, and abbreviated variable names ¹​diabetes,\n#> #   ²​phys_active, ³​bp_sys_ave, ⁴​bp_dia_ave, ⁵​education, ⁶​logged_bmi\n```\n:::\n:::\n\n\nWe can also have different values based on logic conditions using\n`if_else()`. Use @tbl-logic-operators to help with creating the logic\ncondition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    mutate(old = if_else(age >= 30, \"Yes\", \"No\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 10,000 × 9\n#>      age sex      bmi diabetes phys_…¹ bp_sy…² bp_di…³ educa…⁴ old  \n#>    <int> <fct>  <dbl> <fct>    <fct>     <int>   <int> <fct>   <chr>\n#>  1    34 male    32.2 No       No          113      85 High S… Yes  \n#>  2    34 male    32.2 No       No          113      85 High S… Yes  \n#>  3    34 male    32.2 No       No          113      85 High S… Yes  \n#>  4     4 male    15.3 No       <NA>         NA      NA <NA>    No   \n#>  5    49 female  30.6 No       No          112      75 Some C… Yes  \n#>  6     9 male    16.8 No       <NA>         86      47 <NA>    No   \n#>  7     8 male    20.6 No       <NA>        107      37 <NA>    No   \n#>  8    45 female  27.2 No       Yes         118      64 Colleg… Yes  \n#>  9    45 female  27.2 No       Yes         118      64 Colleg… Yes  \n#> 10    45 female  27.2 No       Yes         118      64 Colleg… Yes  \n#> # … with 9,990 more rows, and abbreviated variable names\n#> #   ¹​phys_active, ²​bp_sys_ave, ³​bp_dia_ave, ⁴​education\n```\n:::\n:::\n\n\n::: {.callout-tip appearance=\"default\"}\nRecall that the original dataset doesn't change. If we want the added\nvariable to be saved, we must assign it to something with `<-`. Putting\nit all together, you would enter something like this (no need to type\nthis out yourself):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_update <- nhanes_small %>%\n    mutate(old = if_else(age >= 30, \"Yes\", \"No\"))\n```\n:::\n\n:::\n\nBefore you start the following exercise, run `{styler}`\n(`Ctrl-Shift-P`, then type \"style file\") and commit all the files changes to the Git\nhistory with the RStudio Git interface (`Ctrl-Shift-P`, then type \"commit\").\n\n## Exercise: Piping, filtering, and mutating\n\n> Time: 20 minutes.\n\nCopy and paste the code below into the `learning.R` script file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. BMI between 20 and 40 with diabetes\nnhanes_small %>%\n    # Format should follow: variable >= number or character\n    filter(___ >= ___ & ___ <= ___ & ___ == ___)\n\n# Pipe the data into mutate function and:\nnhanes_modified <- nhanes_small %>% # Specifying dataset\n    mutate(\n        # 2. Calculate mean arterial pressure\n        ___ = ___,\n        # 3. Create young_child variable using a condition\n        ___ = if_else(___, \"Yes\", \"No\")\n    )\n\nnhanes_modified\n```\n:::\n\n\nThen, start replacing the `___` with the appropriate code to complete\nthe tasks below. (*Hint*: Create a new \"Section\" in the R script for\nthis exercise by using `Ctrl-Shift-R`).\n\n1.  Filter `nhanes_small` so only those participants with a BMI of more\n    than or equal to 20 *and* less than or equal to 40, *and* keep those\n    who have diabetes.\n\n2.  Create a new variable called `mean_arterial_pressure` by applying\n    the formula:\n\n    $$((2 * SBP) + SBP) / 3$$\n\n    (DBP = `bp_dia_ave` and SBP = `bp_sys_ave`) to calculate [Mean\n    Arterial\n    Pressure](https://en.wikipedia.org/wiki/Mean_arterial_pressure).\n    *Hint*: In R, use `+` to add, `*` to multiply, and `/` to divide.\n\n3.  Create a new variable called `young_child` for cases where age is\n    less than 6 years.\n\n4.  Finally, add and commit these changes to the Git history with the\n    RStudio Git Interface. Push to GitHub to synchronize with your\n    GitHub repository.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n# 1. BMI between 20 and 40, with diabetes\nnhanes_small %>%\n    filter(bmi >= 20 & bmi <= 40 & diabetes == \"Yes\")\n\n# Pipe the data into mutate function and:\nnhanes_modified <- nhanes_small %>% # dataset\n    mutate(\n        mean_arterial_pressure = ((2 * bp_dia_ave) + bp_sys_ave) / 3,\n        young_child = if_else(age < 6, \"Yes\", \"No\")\n    )\n\nnhanes_modified\n```\n:::\n\n\n## Split-apply-combine: Summarizing data\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nSummarising or applying simple (or complex) statistics to data is a key\ncomponent of any analysis. Simple summaries or statistics can be done\neither on all of the data or on groups of it. There are many data\nanalysis tasks that can be approached using the\n[split-apply-combine](https://www.jstatsoft.org/article/view/v040i01)\nmethod, which involves splitting the data into groups, applying some\nanalysis to each group, and then combining the results together.\n\nIn `{dplyr}`, you can use the function called `summarise()` to summarise\non all the data. If you want to do a split-apply-combine analysis to,\ne.g., find the max height by education status, you would use the\nfunctions `group_by()` and then `summarise()`. Using `group_by()` splits\nthe data up and `summarise()` applies an analysis, then immediately\ncombines it back together.\n\nThe first position argument to `group_by()` is, as usual, the dataset.\nThe next arguments are the columns that contain the values you want to\ngroup by. These columns must contain **categorical** data (e.g.\neducation). `group_by()` tells R to compute the next operations on the\ndata within each grouping, rather than on all the data.\n\nAs with the other functions, `summarise()` takes the dataset as the\nfirst position argument. The next arguments work similar to the\narguments in `mutate()` with one difference: the output must create a\nsingle value (e.g. a mean). Like `mutate()`, you can add multiple\n\"summaries\" by adding new columns separated by `,`. You would use\n`summarise()` to derive basic descriptive statistics of a certain\nvariable, including `min()`, `max()`, `mean()`, `median()`, or `sd()`\n(standard deviation).\n\nThe `group_by()` function doesn't do anything by itself so should always\nbe used in combination with a `summarise()`, `mutate()`, `arrange()`, or\nother function. However, the `summarise()` function can be used on its\nown.\n:::\n\n## Calculating summary statistics\n\nLet's calculate the maximum value of the BMI variable. See what happens\nwhen you enter the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    summarise(max_bmi = max(bmi))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 1 × 1\n#>   max_bmi\n#>     <dbl>\n#> 1      NA\n```\n:::\n:::\n\n\nWe get back a result of `NA`, which means \"missing\". In R, `NA` values\n\"propagate\", meaning that if there is one value missing, then the max or\nmean will also be missing. So, we need to tell `max()` to exclude any\n`NA` values from the calculation using the argument `na.rm = TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    summarise(max_bmi = max(bmi, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 1 × 1\n#>   max_bmi\n#>     <dbl>\n#> 1    81.2\n```\n:::\n:::\n\n\nTo calculate another summary statistic, you would add another summary\ncolumn using `,`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    summarise(max_bmi = max(bmi, na.rm = TRUE),\n              min_bmi = min(bmi, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 1 × 2\n#>   max_bmi min_bmi\n#>     <dbl>   <dbl>\n#> 1    81.2    12.9\n```\n:::\n:::\n\n\nBefore you start the following exercise, add and commit changes to the\nGit history with the RStudio Git interface.\n\n## Summary statistics by a group {#sec-group-by-summarise}\n\nWhile the `summarise()` function is useful enough on its own, it really\nshines when combined with `group_by()`.\n\nLet's use these functions to find out the mean age and BMI between those\nwith and without diabetes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    group_by(diabetes) %>% \n    summarise(mean_age = mean(age, na.rm = TRUE),\n              mean_bmi = mean(bmi, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 3 × 3\n#>   diabetes mean_age mean_bmi\n#>   <fct>       <dbl>    <dbl>\n#> 1 No          35.4      26.2\n#> 2 Yes         59.2      32.6\n#> 3 <NA>         1.20     29.6\n```\n:::\n:::\n\n\n*Quick note*: If you are using a version of dplyr \\>= 1.0.0, you'll get\na message informing you that it is `regrouping output`. This is a\nnotification and can be ignored. If you don't want the message\ndisplayed, you can add `options(dplyr.summarise.inform = FALSE)` to the\ntop of your script and run it.\n\nWe also get a warning about there being missing values in diabetes, so\nwe need to remove rows that have missing diabetes status values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    # Recall ! means \"NOT\", so !is.na means \"is not missing\"\n    filter(!is.na(diabetes)) %>% \n    group_by(diabetes) %>% \n    summarise(mean_age = mean(age, na.rm = TRUE),\n              mean_bmi = mean(bmi, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 2 × 3\n#>   diabetes mean_age mean_bmi\n#>   <fct>       <dbl>    <dbl>\n#> 1 No           35.4     26.2\n#> 2 Yes          59.2     32.6\n```\n:::\n:::\n\n\nCool! We can add more columns to the grouping, so let's do that. Let's\ncompare mean age and BMI by physical activity and diabetes status.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    filter(!is.na(diabetes)) %>% \n    group_by(diabetes, phys_active) %>% \n    summarise(mean_age = mean(age, na.rm = TRUE),\n              mean_bmi = mean(bmi, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 6 × 4\n#>   diabetes phys_active mean_age mean_bmi\n#>   <fct>    <fct>          <dbl>    <dbl>\n#> 1 No       No             46.2      28.8\n#> 2 No       Yes            37.9      26.8\n#> 3 No       <NA>            6.02     17.9\n#> 4 Yes      No             61.7      33.4\n#> 5 Yes      Yes            55.7      31.2\n#> 6 Yes      <NA>           13.7      26.1\n```\n:::\n:::\n\n\nSince we don't need the dataset grouped anymore, it's good practice to\nend the grouping with `ungroup()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnhanes_small %>%\n    filter(!is.na(diabetes)) %>% \n    group_by(diabetes, phys_active) %>% \n    summarise(mean_age = mean(age, na.rm = TRUE),\n              mean_bmi = mean(bmi, na.rm = TRUE)) %>% \n    ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 6 × 4\n#>   diabetes phys_active mean_age mean_bmi\n#>   <fct>    <fct>          <dbl>    <dbl>\n#> 1 No       No             46.2      28.8\n#> 2 No       Yes            37.9      26.8\n#> 3 No       <NA>            6.02     17.9\n#> 4 Yes      No             61.7      33.4\n#> 5 Yes      Yes            55.7      31.2\n#> 6 Yes      <NA>           13.7      26.1\n```\n:::\n:::\n\n\nBefore you start the following exercise, run `{styler}`\n(`Ctrl-Shift-P`, then type \"style file\") and commit changes to the Git history\n(`Ctrl-Shift-P`, then type \"commit\").\n\n## Saving datasets as files\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nGo over how to save data to a file, but don't cover the `{here}` package\nright away. Let them read about it in the section below and then briefly\ncover it again.\n:::\n\nThe `nhanes_small` data frame you created is only available after you've\ncreated it from NHAHES, but if you want to access it later, you can save\nit as a `.csv` file in your `data/` folder using the function\n`readr::write_csv()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(\n  nhanes_small,\n  here::here(\"data/nhanes_small.csv\")\n)\n```\n:::\n\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nThere's a new thing `here()`! The `{here}` package uses a function\ncalled `here()` to make it easier to manage *file paths* within an R\nProject.\n\nSo, what is a file path and why is this `{here}` package necessary? A\nfile path is the list of folders a file is found in. For instance, your\nCV may be found in `/Users/Documents/personal_things/CV.docx`. The\nproblem with file paths when running code (like with R) is that when you\nrun a script interactively (e.g. what we do in class and normally), the\nfile path and \"working directory\" (the R Session) are located at the\nProject level (where the `.Rproj` file is found). You can see the\nworking directory by looking at the top of the RStudio Console.\n\nBut! When you `source()` an R script or run it *not* interactively, the\nR code may likely run *in the folder it is saved in*, e.g. in the `R/`\nfolder. So your file path `data/nhanes_small.csv` won't work because\nthere isn't a folder called `data/` in the `R/` folder.\n\n    LearningR <-- R Project working directory starts here.\n    ├── R\n    │   ├── README.md\n    │   └── learning.R <-- Working directory when running not interactively.\n    ├── data\n    │   └── README.md\n    ├── data-raw\n    │   └── README.md\n    ├── doc\n    │   └── README.md\n    ├── .gitignore\n    ├── DESCRIPTION\n    ├── LearningR.Rproj <-- here() moves file path to start in this file's folder.\n    ├── README.md\n    └── TODO.md\n\nOften people use the function `setwd()` in scripts, but this is *never*\na good idea since using it makes your script *runnable only on your\ncomputer*... which makes it no longer reproducible. We use the `here()`\nfunction to tell R to go to the project root (where the `.Rproj` file is\nfound) and then use that file path. This simple function can make your\nwork more reproducible and easier for you to use later on.\n:::\n\nFor many projects, it isn't necessary or advisable to save every single\ndata object you create. It's better to let the code create the data\nyou'll use rather than saving each new wrangled dataset you might\ncreate. However, sometimes you will want or need to save the dataset\nyou've been working on, perhaps because you've done a lot of work to\nprepare it for later analyses, or because you've run an analysis and\nwant to save the results. In these cases, you should definitely save the\nnew cleaned dataset.\n\n## Loading in a dataset\n\n::: callout-note\n## Reading task: \\~5 minutes\n\nWe've been using a teaching dataset that we load from a package, mainly\nso that we can focus on getting familiar with data wrangling. However,\nthere will come a time when you want to wrangle your own data. There are\nseveral ways to load in a dataset, with the most common being:\n\n1.  Using the RStudio menu\n    `File -> Import Dataset -> From Text/Excel/SPSS/SAS/Stata`\n    (depending on your file type you want to import).\n\n2.  If the file is a `.csv` file, use `readr::read_csv()` to import the\n    dataset, for instance with the `nhanes_small`:\n\n    ``` r\n    nhanes_small <- readr::read_csv(here::here(\"data/nhanes_small.csv\"))\n    ```\n\n3.  If the dataset is a `.rda` file, use `load()`:\n\n    ``` r\n    load(here::here(\"data/dataset_name.rda\"))    \n    ```\n\n    This loads the dataset into your R session so that you can use it\n    again.\n\nFor SAS, SPSS, or Stata files, you can use the package\n[haven](https://haven.tidyverse.org/) to import those types of data\nfiles into R.\n:::\n\n## Summary\n\n-   With tidy data, each variable has its own column, each observation\n    has its own row, and each value has its own cell.\n-   Use the tidyverse to load in multiple packages to tidy up data.\n-   Never edit raw data. Instead, use R code to make changes and clean\n    up the raw data, rather than manually editing the dataset.\n-   Use the functions `select()`, `rename()`, `filter()`, `mutate()`\n    (\"change or modify\"), `arrange()` and `summarise()` from the dplyr\n    package to wrangle your data.\n-   Use the pipe (`%>%`) to write easy-to-read code, similar to reading\n    a text consisting of multiple sentences.\n",
    "supporting": [
      "data-management_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}